{% comment %}
OpenCascade.js initialization include for Spoke documentation site.
Usage in any page:

  {% include ocjs_init.html container_id="my-viewer" %}

This include automatically creates a <div> with the specified container_id (default 'ocjs-viewer')
with responsive sizing and loads OpenCascade.js along with Three.js utilities.

After including this, you can:
1. Use window.ocjsReady Promise to access OpenCascade.js
2. Use window.cascadeViewer utilities for 3D visualization
3. Call window.cascadeViewer.displayModel(shape) to show any OpenCascade shape
{% endcomment %}

<!-- CSS to hide cascade code blocks during loading to prevent flash -->
<style>
  /* Hide cascade code blocks initially to prevent jarring flash during load */
  code.language-cascade {
    display: none !important;
  }
  
  /* Also hide the pre elements containing cascade code */
  pre:has(code.language-cascade) {
    display: none !important;
  }
  
  /* Fallback for browsers that don't support :has() */
  pre code.language-cascade {
    display: none !important;
  }
  
  /* Hide any pre elements that contain cascade text (additional fallback) */
  pre {
    &:has(code.language-cascade) {
      display: none !important;
    }
  }
</style>

<!-- Viewer container -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}" style="width: 100%; height: 600px; max-width: 100%; margin: 0 auto; border: 1px solid #ccc;"></div>

<!-- Code editor container (hidden by default) -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}-editor-container" style="display: none; margin: 10px 0; border: 1px solid #dee2e6; border-radius: 4px; background: #f8f9fa;">
  <!-- Editor header -->
  <div style="background: #e9ecef; padding: 10px; border-bottom: 1px solid #dee2e6; border-radius: 4px 4px 0 0;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h5 style="margin: 0; color: #495057;">Code Editor</h5>
      <div>
        <button id="{{ include.container_id | default: 'ocjs-viewer' }}-copy-code" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px; margin-right: 5px;">Copy Code</button>
        <button id="{{ include.container_id | default: 'ocjs-viewer' }}-editor-close" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Ace Editor -->
  <div id="{{ include.container_id | default: 'ocjs-viewer' }}-ace-editor" style="width: 100%; height: 400px;"></div>
  
  <!-- Error display area -->
  <div id="{{ include.container_id | default: 'ocjs-viewer' }}-error-display" style="display: none; margin: 15px; padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24;">
    <h5 style="margin: 0 0 10px 0; color: #721c24;">Error</h5>
    <pre id="{{ include.container_id | default: 'ocjs-viewer' }}-error-message" style="margin: 0; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 13px;"></pre>
  </div>
</div>

<!-- All buttons container (hidden by default) -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}-export-buttons" style="display: none; text-align: center; margin: 10px 0; padding: 15px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
  <!-- First row: Control buttons -->
  <div style="margin-bottom: 10px;">
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-edit-code" style="margin: 0 5px; padding: 8px 16px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">EDIT</button>
    
    <!-- Editor control buttons (hidden by default, shown when editor is open) -->
    <span id="{{ include.container_id | default: 'ocjs-viewer' }}-editor-controls" style="display: none;">
      <button id="{{ include.container_id | default: 'ocjs-viewer' }}-run-code" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 8px 16px; cursor: pointer; font-size: 14px; margin: 0 5px;">RUN</button>
      <button id="{{ include.container_id | default: 'ocjs-viewer' }}-undo-code" style="background: #ffc107; color: #212529; border: none; border-radius: 4px; padding: 8px 16px; cursor: pointer; font-size: 14px; margin: 0 5px;">UNDO</button>
      <button id="{{ include.container_id | default: 'ocjs-viewer' }}-reset-code" style="background: #6c757d; color: white; border: none; border-radius: 4px; padding: 8px 16px; cursor: pointer; font-size: 14px; margin: 0 5px;">RESET</button>
    </span>
    
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-spin-toggle" style="margin: 0 5px; padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">SPIN: ON</button>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-frame-toggle" style="margin: 0 5px; padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">FRAME: HIDE</button>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-shading-toggle" style="margin: 0 5px; padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">SHADING: GRAY</button>
  </div>
  
  <!-- Second row: Export buttons (centered) -->
  <div>
    <span style="margin: 0 10px 0 0; font-weight: bold; color: #495057; vertical-align: middle;">Export:</span>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-step" style="margin: 0 5px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">STEP</button>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-stl" style="margin: 0 5px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">STL</button>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-gltf" style="margin: 0 5px; padding: 8px 16px; background: #ffc107; color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">GLTF</button>
  </div>
</div>


<!-- Import map for OpenCascade.js and Three.js ES modules -->
<script type="importmap">
{
  "imports": {
    "opencascade.js": "https://unpkg.com/opencascade.js@1.1.1/dist/opencascade.wasm.js",
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js",
    "three/addons/loaders/GLTFLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js",
    "three/addons/exporters/GLTFExporter.js": "https://unpkg.com/three@0.160.0/examples/jsm/exporters/GLTFExporter.js",
    "three/addons/utils/BufferGeometryUtils.js": "https://unpkg.com/three@0.160.0/examples/jsm/utils/BufferGeometryUtils.js",
    "ace-builds": "https://cdn.skypack.dev/ace-builds@1.32.6",
    "ace-builds/": "https://cdn.skypack.dev/ace-builds@1.32.6/"
  }
}
</script>

<!-- Load OpenCascade.js, Three.js utilities, and Ace Editor -->
<script type="module">
import initOpenCascade from 'opencascade.js';
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

// Import Ace Editor as ES module
import ace from 'ace-builds';
import 'ace-builds/src-noconflict/mode-javascript';
import 'ace-builds/src-noconflict/theme-monokai';

// Make ace globally available for the cascadeViewer
window.ace = ace;
console.log('✅ Ace Editor loaded as ES module');

/**
 * window.ocjsReady is a Promise that resolves with the initialized OpenCascade.js module.
 */
window.ocjsReady = initOpenCascade({
  locateFile: function(path, prefix) {
    // Return the unpkg CDN path for WASM files
    if (path.endsWith('.wasm')) {
      // return 'https://unpkg.com/opencascade.js@2.0.0-beta.b5ff984/dist/' + path;
      return 'https://unpkg.com/opencascade.js@1.1.1/dist/' + path;
    }
    return prefix + path;
  }
}).then(oc => {
  console.log('OpenCascade.js loaded successfully from unpkg CDN');
  return oc;
}).catch(error => {
  console.error('Failed to load OpenCascade.js:', error);
  throw error;
});

/**
 * window.cascadeViewer provides utilities for CAD visualization
 */
window.cascadeViewer = {
  // Store current model data for export
  currentModelData: {
    shape: null,
    geometry: null,
    oc: null,
    containerId: null
  },

  // Spin state - default to true (spinning enabled)
  spinEnabled: true,

  // Frame rendering mode - HIDE, LIGHT, DARK
  frameMode: 'HIDE',

  // Shading mode - BLACK, GRAY, OFF
  shadingMode: 'GRAY',

  // Show export buttons after successful model load
  showExportButtons: function(containerId) {
    // Show the unified buttons container
    const exportButtonsId = containerId + '-export-buttons';
    const exportButtons = document.getElementById(exportButtonsId);
    if (exportButtons) {
      exportButtons.style.display = 'block';
      console.log('✅ Unified button container shown for container:', containerId);
    }
  },

  // Hide export buttons
  hideExportButtons: function(containerId) {
    // Hide the unified buttons container
    const exportButtonsId = containerId + '-export-buttons';
    const exportButtons = document.getElementById(exportButtonsId);
    if (exportButtons) {
      exportButtons.style.display = 'none';
    }
  },

  // Setup export button event handlers
  setupExportHandlers: function(containerId) {
    const editBtn = document.getElementById(containerId + '-edit-code');
    const spinBtn = document.getElementById(containerId + '-spin-toggle');
    const frameBtn = document.getElementById(containerId + '-frame-toggle');
    const shadingBtn = document.getElementById(containerId + '-shading-toggle');
    const stepBtn = document.getElementById(containerId + '-export-step');
    const stlBtn = document.getElementById(containerId + '-export-stl');
    const gltfBtn = document.getElementById(containerId + '-export-gltf');

    if (editBtn) {
      editBtn.onclick = () => this.showCodeEditor(containerId);
    }
    if (spinBtn) {
      spinBtn.onclick = () => this.toggleSpin(containerId);
    }
    if (frameBtn) {
      frameBtn.onclick = () => this.toggleFrame(containerId);
    }
    if (shadingBtn) {
      shadingBtn.onclick = () => this.toggleShading(containerId);
    }
    if (stepBtn) {
      stepBtn.onclick = () => this.exportSTEP();
    }
    if (stlBtn) {
      stlBtn.onclick = () => this.exportSTL();
    }
    if (gltfBtn) {
      gltfBtn.onclick = () => this.exportGLTF();
    }
    console.log('✅ Export and edit button handlers setup for container:', containerId);
  },

  // Toggle spin animation on/off
  toggleSpin: function(containerId) {
    this.spinEnabled = !this.spinEnabled;
    const spinBtn = document.getElementById(containerId + '-spin-toggle');
    if (spinBtn) {
      spinBtn.textContent = this.spinEnabled ? 'SPIN: ON' : 'SPIN: OFF';
      spinBtn.style.background = this.spinEnabled ? '#17a2b8' : '#6c757d';
    }
    
    // Update status to show spin state change
    const status = this.spinEnabled ? 'enabled' : 'disabled';
    this.updateStatus(containerId, `Model spinning ${status}`, 'info', 2000);
    console.log(`🔄 Model spinning ${status}`);
  },

  // Toggle frame rendering mode: HIDE -> LIGHT -> DARK -> HIDE
  toggleFrame: function(containerId) {
    // Cycle through the three states
    if (this.frameMode === 'HIDE') {
      this.frameMode = 'LIGHT';
    } else if (this.frameMode === 'LIGHT') {
      this.frameMode = 'DARK';
    } else {
      this.frameMode = 'HIDE';
    }
    
    const frameBtn = document.getElementById(containerId + '-frame-toggle');
    if (frameBtn) {
      frameBtn.textContent = `FRAME: ${this.frameMode}`;
      // Set button colors based on state
      if (this.frameMode === 'HIDE') {
        frameBtn.style.background = '#6c757d'; // Gray for hidden
      } else if (this.frameMode === 'LIGHT') {
        frameBtn.style.background = '#ffc107'; // Yellow for light
        frameBtn.style.color = 'black';
      } else { // DARK
        frameBtn.style.background = '#343a40'; // Dark gray for dark
        frameBtn.style.color = 'white';
      }
    }
    
    // Apply the frame rendering changes to the current model
    this.updateFrameRendering(containerId);
    
    // Update status to show frame state change
    this.updateStatus(containerId, `Frame rendering: ${this.frameMode}`, 'info', 2000);
    console.log(`🔺 Frame rendering: ${this.frameMode}`);
  },

  // Toggle shading mode: GRAY -> BLACK -> OFF -> GRAY
  toggleShading: function(containerId) {
    // Cycle through the three states
    if (this.shadingMode === 'GRAY') {
      this.shadingMode = 'BLACK';
    } else if (this.shadingMode === 'BLACK') {
      this.shadingMode = 'OFF';
    } else {
      this.shadingMode = 'GRAY';
    }
    
    const shadingBtn = document.getElementById(containerId + '-shading-toggle');
    if (shadingBtn) {
      shadingBtn.textContent = `SHADING: ${this.shadingMode}`;
      // Set button colors based on state
      if (this.shadingMode === 'BLACK') {
        shadingBtn.style.background = '#343a40'; // Dark gray for black
        shadingBtn.style.color = 'white';
      } else if (this.shadingMode === 'GRAY') {
        shadingBtn.style.background = '#6c757d'; // Gray
        shadingBtn.style.color = 'white';
      } else { // OFF
        shadingBtn.style.background = '#dc3545'; // Red for off
        shadingBtn.style.color = 'white';
      }
    }
    
    // Apply the shading changes to the current model
    this.updateShading(containerId);
    
    // Update status to show shading state change
    this.updateStatus(containerId, `Polygon shading: ${this.shadingMode}`, 'info', 2000);
    console.log(`🎨 Polygon shading: ${this.shadingMode}`);
  },

  // Update frame rendering based on current frameMode
  updateFrameRendering: function(containerId) {
    // Control the wireframe skeleton (frame outlines) instead of main polygons
    if (window.cadWireframe) {
      if (this.frameMode === 'HIDE') {
        // Hide the wireframe skeleton
        window.cadWireframe.visible = false;
      } else {
        // Show the wireframe skeleton
        window.cadWireframe.visible = true;
        
        // Update wireframe material based on LIGHT or DARK mode
        if (window.cadWireframe.material) {
          if (this.frameMode === 'LIGHT') {
            // Light mode - bright wireframe
            window.cadWireframe.material.color.setHex(0xffffff); // White
            window.cadWireframe.material.opacity = 0.6;
            window.cadWireframe.material.transparent = true;
          } else { // DARK
            // Dark mode - dark wireframe
            window.cadWireframe.material.color.setHex(0x333333); // Dark gray
            window.cadWireframe.material.opacity = 0.8;
            window.cadWireframe.material.transparent = true;
          }
          window.cadWireframe.material.needsUpdate = true;
        }
      }
    }
    
    console.log(`🔺 Applied wireframe rendering: ${this.frameMode}`);
  },

  // Update shading based on current shadingMode
  updateShading: function(containerId) {
    // Control the main CAD model polygon shading
    if (window.cadModel) {
      if (this.shadingMode === 'OFF') {
        // Hide the main polygon model
        window.cadModel.visible = false;
      } else {
        // Show the main polygon model
        window.cadModel.visible = true;
        
        // Update material based on BLACK or GRAY mode
        window.cadModel.traverse((child) => {
          if (child.isMesh && child.material) {
            if (this.shadingMode === 'BLACK') {
              // Black shading
              child.material.color.setHex(0x202020); // Dark gray/black
              child.material.opacity = 1.0;
              child.material.transparent = false;
            } else { // GRAY
              // Gray shading
              child.material.color.setHex(0xE0E0E0); // Light gray
              child.material.opacity = 1.0;
              child.material.transparent = false;
            }
            child.material.needsUpdate = true;
          }
        });
      }
    }
    
    console.log(`🎨 Applied polygon shading: ${this.shadingMode}`);
  },

  // Get page name for filename
  getPageName: function() {
    // Try to get page name from title, URL, or fallback to 'model'
    let pageName = 'model';
    
    // First try document title
    if (document.title) {
      pageName = document.title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
        .replace(/\s+/g, '-') // Replace spaces with hyphens
        .replace(/-+/g, '-') // Replace multiple hyphens with single
        .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
    }
    
    // Fallback to pathname if title is empty or generic
    if (!pageName || pageName === 'model' || pageName.length < 2) {
      const pathname = window.location.pathname;
      const pathParts = pathname.split('/').filter(part => part.length > 0);
      if (pathParts.length > 0) {
        pageName = pathParts[pathParts.length - 1]
          .replace(/\.html?$/, '') // Remove .html extension
          .replace(/[^a-z0-9-]/g, '') // Keep only alphanumeric and hyphens
          .toLowerCase();
      }
    }
    
    return pageName || 'model';
  },

  // Export functions (dummy implementations for now)
  exportSTEP: function() {
    console.log('📁 Exporting STEP file...');
    const filename = this.getPageName() + '.step';
    
    if (!this.currentModelData.shape || !this.currentModelData.oc) {
      console.error('❌ No OpenCascade shape data available for STEP export');
      this.updateStatus('viewer', 'STEP export failed - No model data available', 'error', 0);
      alert('Error: No OpenCascade model data available for STEP export');
      return;
    }
    
    try {
      const oc = this.currentModelData.oc;
      const shape = this.currentModelData.shape;
      
      console.log('🔧 Creating STEP writer...');
      const writer = new oc.STEPControl_Writer_1();
      
      console.log('📦 Transferring shape to STEP format...');
      writer.Transfer(
        shape,
        oc.STEPControl_StepModelType.STEPControl_AsIs,
        true
      );
      
      console.log('💾 Writing STEP file...');
      // Use the exact filename that worked in our experimental function
      const tempFilename = 'test.step';
      writer.Write(tempFilename);
      
      console.log('📖 Reading STEP content...');
      // Use the exact approach that worked: direct filename, no path prefix
      const stepContent = oc.FS.readFile(tempFilename, { encoding: 'utf8' });
      
      console.log('📁 Downloading STEP file...');
      this.downloadFile(filename, stepContent, 'application/step');
      
      console.log('✅ STEP export completed:', filename, `(${stepContent.length} bytes)`);
      
      // Update status
      this.updateStatus('viewer', `STEP file exported successfully: ${filename}`, 'success', 3000);
      
    } catch (error) {
      console.error('❌ Error exporting STEP:', error);
      this.updateStatus('viewer', `STEP export failed: ${error.message}`, 'error', 0);
      alert('Error exporting STEP file: ' + error.message);
    }
  },

  exportSTL: function() {
    console.log('📁 Exporting STL file...');
    const filename = this.getPageName() + '.stl';
    
    if (!this.currentModelData.geometry) {
      console.error('❌ No geometry data available for STL export');
      this.updateStatus('viewer', 'STL export failed - No geometry data available', 'error', 0);
      alert('Error: No model data available for export');
      return;
    }
    
    try {
      const stlContent = this.generateSTLContent(this.currentModelData.geometry);
      this.downloadFile(filename, stlContent, 'model/stl');
      console.log('✅ STL file exported successfully:', filename);
      
      // Update status
      this.updateStatus('viewer', `STL file exported successfully: ${filename}`, 'success', 3000);
    } catch (error) {
      console.error('❌ Error exporting STL:', error);
      this.updateStatus('viewer', `STL export failed: ${error.message}`, 'error', 0);
      alert('Error exporting STL file: ' + error.message);
    }
  },

  exportGLTF: function() {
    console.log('📁 Exporting GLTF file...');
    const filename = this.getPageName() + '.gltf';
    
    if (!this.currentModelData.geometry) {
      console.error('❌ No geometry data available for GLTF export');
      this.updateStatus('viewer', 'GLTF export failed - No geometry data available', 'error', 0);
      alert('Error: No model data available for export');
      return;
    }
    
    try {
      this.generateGLTFContent(this.currentModelData.geometry, filename);
      console.log('✅ GLTF export initiated:', filename);
      
      // Update status
      this.updateStatus('viewer', `GLTF file exported successfully: ${filename}`, 'success', 3000);
    } catch (error) {
      console.error('❌ Error exporting GLTF:', error);
      this.updateStatus('viewer', `GLTF export failed: ${error.message}`, 'error', 0);
      alert('Error exporting GLTF file: ' + error.message);
    }
  },

  // Helper function to download dummy files
  downloadDummyFile: function(filename, content) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log('✅ Downloaded dummy file:', filename);
  },

  // Helper function to download files with proper MIME types
  downloadFile: function(filename, content, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log('✅ Downloaded file:', filename);
  },

  // Generate STL content from Three.js geometry
  generateSTLContent: function(geometry) {
    console.log('🔧 Generating STL content from geometry...');
    
    const vertices = geometry.attributes.position.array;
    const indices = geometry.index ? geometry.index.array : null;
    const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
    
    let stlContent = 'solid OpenCascadeModel\n';
    
    // If geometry is indexed, use indices to create triangles
    if (indices) {
      for (let i = 0; i < indices.length; i += 3) {
        const i1 = indices[i] * 3;
        const i2 = indices[i + 1] * 3;
        const i3 = indices[i + 2] * 3;
        
        // Get vertices
        const v1 = [vertices[i1], vertices[i1 + 1], vertices[i1 + 2]];
        const v2 = [vertices[i2], vertices[i2 + 1], vertices[i2 + 2]];
        const v3 = [vertices[i3], vertices[i3 + 1], vertices[i3 + 2]];
        
        // Calculate normal if not provided
        let normal;
        if (normals) {
          normal = [normals[i1], normals[i1 + 1], normals[i1 + 2]];
        } else {
          // Calculate normal from cross product
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          // Normalize
          const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
        }
        
        stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
        stlContent += '    outer loop\n';
        stlContent += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
        stlContent += '    endloop\n';
        stlContent += '  endfacet\n';
      }
    } else {
      // Non-indexed geometry - process vertices in groups of 3
      for (let i = 0; i < vertices.length; i += 9) {
        const v1 = [vertices[i], vertices[i + 1], vertices[i + 2]];
        const v2 = [vertices[i + 3], vertices[i + 4], vertices[i + 5]];
        const v3 = [vertices[i + 6], vertices[i + 7], vertices[i + 8]];
        
        // Calculate normal
        let normal;
        if (normals) {
          normal = [normals[i], normals[i + 1], normals[i + 2]];
        } else {
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
        }
        
        stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
        stlContent += '    outer loop\n';
        stlContent += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
        stlContent += '    endloop\n';
        stlContent += '  endfacet\n';
      }
    }
    
    stlContent += 'endsolid OpenCascadeModel\n';
    
    console.log(`✅ Generated STL with ${indices ? indices.length / 3 : vertices.length / 9} triangles`);
    return stlContent;
  },

  // Generate GLTF content from Three.js geometry
  generateGLTFContent: function(geometry, filename) {
    console.log('🔧 Generating GLTF content from geometry...');
    
    // Create a temporary scene with the geometry
    const scene = new THREE.Scene();
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x888888,
      metalness: 0.1,
      roughness: 0.8,
      opacity: 0.9
    });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    
    // Use GLTFExporter to export the scene
    const exporter = new GLTFExporter();
    
    exporter.parse(
      scene,
      (gltfData) => {
        console.log('✅ GLTF data generated successfully');
        
        // Convert to JSON string for text-based GLTF format
        const gltfString = JSON.stringify(gltfData, null, 2);
        
        // Download the GLTF file
        this.downloadFile(filename, gltfString, 'model/gltf+json');
        console.log(`✅ GLTF file exported successfully: ${filename}`);
      },
      (error) => {
        console.error('❌ Error generating GLTF:', error);
        throw new Error('Failed to generate GLTF data: ' + error.message);
      },
      {
        binary: false, // Export as text-based GLTF, not GLB
        embedImages: true,
        truncateDrawRange: true
      }
    );
  },


  // Convert OpenCascade shape to Three.js mesh data
  convertOpenCascadeToMesh: function(shape, oc) {
    console.log('🔧 Converting OpenCascade shape to mesh...');
    
    try {
      // Use OpenCascade's meshing capabilities
      console.log('🔧 Creating mesher...');
      const mesher = new oc.BRepMesh_IncrementalMesh_2(shape, 0.1, false, 0.5, false);
      console.log('🔧 Performing mesh operation...');
      mesher.Perform();
      
      if (!mesher.IsDone()) {
        throw new Error('Failed to mesh the OpenCascade shape');
      }
      console.log('✅ Meshing completed successfully');
      
      const vertices = [];
      const indices = [];
      const normals = [];
      
      // Iterate through faces to extract mesh data
      console.log('🔍 Exploring faces...');
      const faceExplorer = new oc.TopExp_Explorer_2(shape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);
      
      let vertexOffset = 0;
      let faceCount = 0;
      
      while (faceExplorer.More()) {
        faceCount++;
        
        const face = oc.TopoDS.Face_1(faceExplorer.Current());
        const location = new oc.TopLoc_Location_1();
        const triangulation = oc.BRep_Tool.Triangulation(face, location);
        
        if (!triangulation.IsNull()) {
          // console.log(`  Face ${faceCount} has triangulation data`);
          const transform = location.Transformation();
          
          // Get node and triangle counts using correct API
          const nodeCount = triangulation.get().NbNodes();
          const triangleCount = triangulation.get().NbTriangles();
          
          // Extract vertices
          for (let i = 1; i <= nodeCount; i++) {
            const node = triangulation.get().Node(i);
            const transformedNode = node.Transformed(transform);
            vertices.push(transformedNode.X(), transformedNode.Y(), transformedNode.Z());
          }
          
          // Process each triangle in the face with corrected orientation
          for (let t = 1; t <= triangleCount; t++) {
            const triangle = triangulation.get().Triangle(t);
            const n1 = triangle.Value(1);
            const n2 = triangle.Value(2);
            const n3 = triangle.Value(3);
            
            // Get triangle vertices
            const v1 = triangulation.get().Node(n1).Transformed(transform);
            const v2 = triangulation.get().Node(n2).Transformed(transform);
            const v3 = triangulation.get().Node(n3).Transformed(transform);
            
            // Compute triangle normal using cross product
            const edge1 = new THREE.Vector3(
              v2.X() - v1.X(),
              v2.Y() - v1.Y(),
              v2.Z() - v1.Z()
            );
            const edge2 = new THREE.Vector3(
              v3.X() - v1.X(),
              v3.Y() - v1.Y(),
              v3.Z() - v1.Z()
            );
            
            let normal = edge1.cross(edge2).normalize();
            
            // Get face orientation from OpenCascade
            const faceOrientation = face.Orientation_1();
            
            // Check if face is reversed according to OpenCascade
            const isReversed = (faceOrientation === oc.TopAbs_Orientation.TopAbs_REVERSED);
            
            if (isReversed) {
              // Face is reversed, flip normal and triangle winding
              normal.negate();
              indices.push(
                vertexOffset + n1 - 1,
                vertexOffset + n3 - 1,  // Swapped n2 and n3 for reversed winding
                vertexOffset + n2 - 1
              );
            } else {
              // Face is forward, keep original normal and winding
              indices.push(
                vertexOffset + n1 - 1,
                vertexOffset + n2 - 1,
                vertexOffset + n3 - 1
              );
            }
            
            // Add the corrected normal for all three vertices of the triangle
            for (let j = 0; j < 3; j++) {
              normals.push(normal.x, normal.y, normal.z);
            }
          }
          
          vertexOffset += nodeCount;
        } else {
          console.log(`  Face ${faceCount} has no triangulation data`);
        }
        
        faceExplorer.Next();
      }
      
      console.log(`🔍 Extracted ${vertices.length / 3} vertices, ${indices.length / 3} triangles from ${faceCount} faces`);
      
      if (vertices.length === 0) {
        throw new Error('No vertices extracted from OpenCascade shape');
      }
      
      // Create Three.js geometry
      console.log('🔧 Creating Three.js BufferGeometry...');
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geometry.setIndex(indices);
      
      // Fix shading artifacts by merging vertices and recomputing normals
      console.log('🔧 Merging vertices to fix shading artifacts...');
      const mergedGeometry = BufferGeometryUtils.mergeVertices(geometry, 1e-6);
      mergedGeometry.computeVertexNormals();
      console.log('✅ Vertices merged and normals recomputed for proper shading');
      
      console.log('✅ Three.js geometry created successfully');
      return mergedGeometry;
      
    } catch (error) {
      console.error('❌ Error in convertOpenCascadeToMesh:', error);
      throw error;
    }
  },

  // Export geometry to GLB format
  exportToGLB: function(geometry) {
    return new Promise((resolve, reject) => {
      console.log('📦 Exporting geometry to GLB...');
      
      try {
        const material = new THREE.MeshStandardMaterial({ 
          color: 0x808080,
          metalness: 0.1,
          roughness: 0.4,
          transparent: false,
          opacity: 1.0
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        const scene = new THREE.Scene();
        scene.add(mesh);
        
        console.log('📦 Creating GLTFExporter...');
        const exporter = new GLTFExporter();
        exporter.parse(
          scene,
          (gltf) => {
            console.log('✅ GLB export successful, size:', gltf.byteLength, 'bytes');
            resolve(gltf);
          },
          (error) => {
            console.error('❌ GLB export failed:', error);
            reject(error);
          },
          { binary: true }
        );
      } catch (error) {
        console.error('❌ Error setting up GLB export:', error);
        reject(error);
      }
    });
  },

  // Load GLB and display in Three.js viewer
  loadGLBAndDisplay: function(glbData, containerId = 'viewer') {
    console.log('🎬 Loading GLB data into Three.js viewer...');
    
    const container = document.getElementById(containerId);
    
    // === Initialize Three.js Scene ===
    console.log('🎬 Initializing Three.js scene...');
    
    if (!container) {
      console.error('❌ Viewer container not found');
      return;
    }
    
    // Clear previous content to prevent WebGL context conflicts
    container.innerHTML = '';
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    
    // Create camera with proper aspect ratio
    const containerRect = container.getBoundingClientRect();
    const camera = new THREE.PerspectiveCamera(
      75, 
      containerRect.width / containerRect.height, 
      0.1, 
      1000
    );
    
    // Position camera for good viewing angle
    camera.position.set(80, 60, 80);
    camera.lookAt(24, 16, 18);
    
    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRect.width, containerRect.height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Append renderer to cleared container
    container.appendChild(renderer.domElement);
    
    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(24, 16, 18);
    controls.update();
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.9);  // Increased for softer shading
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);  // Reduced for softer shading
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Load the GLB data
    console.log('📦 Loading GLB data...');
    const loader = new GLTFLoader();
    const blob = new Blob([glbData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    
    loader.load(
      url,
      (gltf) => {
        console.log('✅ GLB loaded successfully');
        const model = gltf.scene;
        
        scene.add(model);
        console.log('✅ Model added to scene');
        
        // Add wireframe overlay
        model.traverse((child) => {
          if (child.isMesh) {
            const wireframe = new THREE.WireframeGeometry(child.geometry);
            const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
              color: 0xFFFFFF, 
              opacity: 0.3, 
              transparent: true 
            }));
            scene.add(line);
            
            // Store references for animation
            window.cadModel = model;
            window.cadWireframe = line;
            console.log('✅ Wireframe overlay added');
            
            // Apply initial frame mode (HIDE by default)
            window.cascadeViewer.updateFrameRendering(containerId);
            
            // Apply initial shading mode (GRAY by default)
            window.cascadeViewer.updateShading(containerId);
          }
        });
        
        // Clean up blob URL
        URL.revokeObjectURL(url);
        
        console.log('✅ Model setup completed successfully!');
        
        // Show export buttons and setup handlers after successful load
        window.cascadeViewer.setupExportHandlers(containerId);
        window.cascadeViewer.showExportButtons(containerId);
      },
      (progress) => {
        console.log('📊 Loading progress:', progress);
      },
      (error) => {
        console.error('❌ Error loading GLB:', error);
        URL.revokeObjectURL(url);
      }
    );
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Rotate the CAD model and wireframe if they exist and spinning is enabled
      if (window.cadModel && window.cadWireframe && window.cascadeViewer.spinEnabled) {
        window.cadModel.rotation.x += 0.005;
        window.cadModel.rotation.y += 0.005;
        window.cadWireframe.rotation.x += 0.005;
        window.cadWireframe.rotation.y += 0.005;
      }
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
    console.log('🎬 Animation loop started');
  },

  // Fallback: Direct Three.js visualization (skip GLB export/import)
  directThreeJSVisualization: function(geometry, containerId = 'viewer') {
    console.log('🎯 Using direct Three.js visualization fallback...');
    
    const container = document.getElementById(containerId);
    
    // Check if a renderer already exists and dispose of it properly
    if (window.threeJSRenderer) {
      console.log('🧹 Disposing existing Three.js renderer');
      window.threeJSRenderer.dispose();
      window.threeJSRenderer = null;
    }
    
    // Clear any existing content completely
    container.innerHTML = '';
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(100, 100, 100);
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false,
      preserveDrawingBuffer: false,
      powerPreference: "high-performance"
    });
    
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Store renderer globally for cleanup
    window.threeJSRenderer = renderer;
    
    // Add renderer canvas to container
    container.appendChild(renderer.domElement);
    
    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.9);  // Increased for softer shading
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);  // Reduced for softer shading
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Create mesh from OpenCascade-derived geometry
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      metalness: 0.1,
      roughness: 0.4,
      transparent: true,
      opacity: 0.9
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    
    // Add wireframe overlay
    const wireframe = new THREE.WireframeGeometry(geometry);
    const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
      color: 0x000000, 
      opacity: 0.3, 
      transparent: true 
    }));
    scene.add(line);
    
    // Store references for animation
    window.cadModel = mesh;
    window.cadWireframe = line;
    
    // Apply initial frame mode (HIDE by default)
    this.updateFrameRendering(containerId);
    
    // Apply initial shading mode (GRAY by default)
    this.updateShading(containerId);
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Only rotate if spinning is enabled
      if (window.cascadeViewer.spinEnabled) {
        mesh.rotation.x += 0.005;
        mesh.rotation.y += 0.005;
        line.rotation.x += 0.005;
        line.rotation.y += 0.005;
      }
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
    console.log('✅ Direct Three.js visualization completed successfully!');
    
    // Show export buttons and setup handlers after successful fallback load
    this.setupExportHandlers(containerId);
    this.showExportButtons(containerId);
  },

  // Main function to display any OpenCascade shape
  displayModel: async function(shape, containerId = 'viewer') {
    try {
      console.log('🚀 Starting OpenCascade.js → GLB → Three.js workflow...');
      
      const oc = await window.ocjsReady;
      
      // Store model data for export
      this.currentModelData = {
        shape: shape,
        geometry: null,
        oc: oc,
        containerId: containerId
      };
      
      // Hide export buttons initially
      this.hideExportButtons(containerId);
      
      // Step 1: Convert OpenCascade shape to Three.js geometry
      console.log('🔧 Step 1: Converting OpenCascade shape to mesh...');
      const geometry = this.convertOpenCascadeToMesh(shape, oc);
      
      // Store geometry for export
      this.currentModelData.geometry = geometry;
      
      // Try GLB workflow first
      try {
        console.log('📦 Step 2: Attempting GLB export/import workflow...');
        // Step 2: Export geometry to GLB
        const glbData = await this.exportToGLB(geometry);
        
        // Step 3: Load GLB and display in Three.js
        this.loadGLBAndDisplay(glbData, containerId);
        
        console.log('✅ CAD viewer GLB workflow completed successfully!');
        
      } catch (glbError) {
        console.warn('⚠️ GLB workflow failed, falling back to direct visualization:', glbError);
        
        // Fallback: Direct Three.js visualization
        this.directThreeJSVisualization(geometry, containerId);
        
        console.log('✅ CAD viewer fallback workflow completed successfully!');
      }
      
    } catch (error) {
      console.error('❌ Error in CAD viewer workflow:', error);
      
      // Ultimate fallback display
      const container = document.getElementById(containerId);
      container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f0f0f0; color: #333; font-family: Arial, sans-serif;">
          <div style="text-align: center;">
            <h3>🔧 OpenCascade.js → Three.js Workflow</h3>
            <p>OpenCascade shape created successfully!</p>
            <p><em>⚠️ 3D viewer encountered an error during processing. Check console for details.</em></p>
            <p><strong>Error:</strong> ${error.message}</p>
          </div>
        </div>
      `;
    }
  },

  // Show code editor for editing cascade code
  showCodeEditor: function(containerId) {
    console.log('✏️ Opening code editor for container:', containerId);
    
    // Show the editor container
    const editorContainer = document.getElementById(containerId + '-editor-container');
    if (!editorContainer) {
      console.error('❌ Editor container not found for:', containerId);
      return;
    }
    
    editorContainer.style.display = 'block';
    
    // Initialize Ace Editor if not already done
    const aceEditorId = containerId + '-ace-editor';
    if (!this.aceEditors) {
      this.aceEditors = {};
    }
    
    if (!this.aceEditors[containerId]) {
      console.log('🔧 Initializing Ace Editor for:', containerId);
      
      // Check if Ace Editor is available (should be loaded as ES module)
      if (typeof window.ace === 'undefined') {
        console.error('❌ Ace Editor ES module not loaded');
        alert('Code editor failed to load. Please refresh the page and try again.');
        return;
      }
      
      // Create the editor
      const editor = window.ace.edit(aceEditorId);
      editor.setTheme('ace/theme/github');
      editor.session.setMode('ace/mode/javascript');
      editor.setOptions({
        fontSize: 14,
        showPrintMargin: false,
        wrap: true,
        enableBasicAutocompletion: true,
        enableLiveAutocompletion: true
      });
      
      // Add keyboard shortcuts for running code (Ctrl+Enter and Ctrl+S)
      editor.commands.addCommand({
        name: 'runCode',
        bindKey: {win: 'Ctrl-Enter', mac: 'Cmd-Enter'},
        exec: () => this.runCodeFromEditor(containerId)
      });
      
      editor.commands.addCommand({
        name: 'runCodeSave',
        bindKey: {win: 'Ctrl-S', mac: 'Cmd-S'},
        exec: () => this.runCodeFromEditor(containerId)
      });
      
      this.aceEditors[containerId] = editor;
      
      // Setup button handlers
      this.setupEditorHandlers(containerId);
    }
    
    // Populate editor with current code
    this.populateEditorWithCurrentCode(containerId);
    
    // Show editor control buttons and hide EDIT button
    const editorControls = document.getElementById(containerId + '-editor-controls');
    const editButton = document.getElementById(containerId + '-edit-code');
    
    if (editorControls) {
      editorControls.style.display = 'inline';
      console.log('✅ Editor control buttons shown');
    }
    
    if (editButton) {
      editButton.style.display = 'none';
      console.log('✅ EDIT button hidden');
    }
    
    // Focus the editor
    setTimeout(() => {
      this.aceEditors[containerId].focus();
    }, 100);
    
    // Update status
    this.updateStatus(containerId, 'Code editor opened', 'info', 2000);
    
    console.log('✅ Code editor opened for:', containerId);
  },
  
  // Setup editor button handlers
  setupEditorHandlers: function(containerId) {
    const runBtn = document.getElementById(containerId + '-run-code');
    const undoBtn = document.getElementById(containerId + '-undo-code');
    const resetBtn = document.getElementById(containerId + '-reset-code');
    const closeBtn = document.getElementById(containerId + '-editor-close');
    const copyBtn = document.getElementById(containerId + '-copy-code');
    
    // Initialize version tracking for this container
    if (!this.editorVersions) {
      this.editorVersions = {};
    }
    if (!this.editorVersions[containerId]) {
      this.editorVersions[containerId] = {
        lastRunCode: null,
        originalCode: null
      };
    }
    
    if (runBtn) {
      runBtn.onclick = () => this.runCodeFromEditor(containerId);
    }
    if (undoBtn) {
      undoBtn.onclick = () => this.undoEditorChanges(containerId);
    }
    if (resetBtn) {
      resetBtn.onclick = () => this.resetEditorCode(containerId);
    }
    if (closeBtn) {
      closeBtn.onclick = () => this.closeCodeEditor(containerId);
    }
    if (copyBtn) {
      copyBtn.onclick = () => this.copyCodeToClipboard(containerId);
    }
  },
  
  // Close code editor
  closeCodeEditor: function(containerId) {
    const editorContainer = document.getElementById(containerId + '-editor-container');
    if (editorContainer) {
      editorContainer.style.display = 'none';
    }
    
    // Hide editor control buttons and show EDIT button
    const editorControls = document.getElementById(containerId + '-editor-controls');
    const editButton = document.getElementById(containerId + '-edit-code');
    
    if (editorControls) {
      editorControls.style.display = 'none';
      console.log('✅ Editor control buttons hidden');
    }
    
    if (editButton) {
      editButton.style.display = 'inline-block';
      console.log('✅ EDIT button shown');
    }
    
    this.hideErrorDisplay(containerId);
    
    // Update status
    this.updateStatus(containerId, 'Code editor closed', 'info', 2000);
    
    console.log('✅ Code editor closed for:', containerId);
  },
  
  // Copy code from editor to clipboard
  copyCodeToClipboard: function(containerId) {
    if (!this.aceEditors[containerId]) {
      console.error('❌ Ace editor not found for container:', containerId);
      this.updateStatus(containerId, 'Error: Editor not available', 'error', 3000);
      return;
    }
    
    try {
      // Get the current code from the Ace editor
      const currentCode = this.aceEditors[containerId].getValue();
      
      if (!currentCode || currentCode.trim() === '') {
        this.updateStatus(containerId, 'No code to copy', 'warning', 2000);
        return;
      }
      
      // Use the modern Clipboard API if available
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(currentCode).then(() => {
          this.updateStatus(containerId, `Code copied to clipboard (${currentCode.length} characters)`, 'success', 3000);
          console.log('✅ Code copied to clipboard via Clipboard API');
        }).catch(err => {
          console.error('❌ Failed to copy via Clipboard API:', err);
          this.fallbackCopyToClipboard(currentCode, containerId);
        });
      } else {
        // Fallback for older browsers or non-secure contexts
        this.fallbackCopyToClipboard(currentCode, containerId);
      }
      
    } catch (error) {
      console.error('❌ Error copying code to clipboard:', error);
      this.updateStatus(containerId, 'Failed to copy code to clipboard', 'error', 3000);
    }
  },
  
  // Fallback copy method for older browsers
  fallbackCopyToClipboard: function(text, containerId) {
    try {
      // Create a temporary textarea element
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      
      // Select and copy the text
      textArea.focus();
      textArea.select();
      
      const successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      
      if (successful) {
        this.updateStatus(containerId, `Code copied to clipboard (${text.length} characters)`, 'success', 3000);
        console.log('✅ Code copied to clipboard via fallback method');
      } else {
        throw new Error('execCommand failed');
      }
      
    } catch (error) {
      console.error('❌ Fallback copy method failed:', error);
      this.updateStatus(containerId, 'Failed to copy code - please select and copy manually', 'error', 5000);
    }
  },
  
  // Populate editor with current cascade code
  populateEditorWithCurrentCode: function(containerId) {
    if (!this.aceEditors[containerId]) return;
    
    console.log('🔍 Populating editor with code for:', containerId);
    console.log('🔍 Stored originalCode:', this.currentModelData.originalCode ? this.currentModelData.originalCode.substring(0, 100) + '...' : 'null');
    
    // Try multiple sources for the code, prioritizing the last successfully run code
    let currentCode = (this.editorVersions && this.editorVersions[containerId] && this.editorVersions[containerId].lastRunCode) ||
                     this.currentModelData.originalCode || 
                     (window.cascadeOriginalCode && window.cascadeOriginalCode[containerId]) ||
                     this.extractCodeFromPage(containerId) || 
                     this.extractCodeFromMarkdown();
    
    console.log('🔍 Code sources checked:');
    console.log('  - lastRunCode (priority):', this.editorVersions && this.editorVersions[containerId] && this.editorVersions[containerId].lastRunCode ? 'found' : 'null');
    console.log('  - currentModelData.originalCode:', this.currentModelData.originalCode ? 'found' : 'null');
    console.log('  - global backup:', window.cascadeOriginalCode && window.cascadeOriginalCode[containerId] ? 'found' : 'null');
    console.log('  - page extraction: will try if needed');
    console.log('  - markdown extraction: will try if needed');
    
    console.log('🔍 Final code source:', currentCode ? currentCode.substring(0, 100) + '...' : 'using default template');
    
    if (!currentCode) {
      // Provide a default template
      currentCode = `function buildModel(oc) {
  // Create your OpenCascade.js model here
  // Example: Simple box
  const box = new oc.BRepPrimAPI_MakeBox_2(50, 50, 50);
  return box.Shape();
}`;
      console.log('⚠️ Using default template - original code not found');
    }
    
    this.aceEditors[containerId].setValue(currentCode, -1);
    
    // Store the original code for RESET functionality
    if (this.editorVersions && this.editorVersions[containerId] && !this.editorVersions[containerId].originalCode) {
      this.editorVersions[containerId].originalCode = currentCode;
      console.log('💾 Stored original code for RESET functionality');
    }
    
    console.log('✅ Editor populated with code for:', containerId);
  },
  
  // Extract code from the current page (fallback)
  extractCodeFromPage: function(containerId) {
    console.log('🔍 Trying to extract code from page...');
    // Try to find cascade code blocks on the page
    const codeBlocks = document.querySelectorAll('code.language-cascade');
    console.log('🔍 Found', codeBlocks.length, 'cascade code blocks');
    if (codeBlocks.length > 0) {
      const code = codeBlocks[0].textContent || codeBlocks[0].innerText;
      console.log('🔍 Extracted code from page:', code.substring(0, 100) + '...');
      return code;
    }
    return null;
  },
  
  // Extract code from markdown content (better fallback)
  extractCodeFromMarkdown: function() {
    console.log('🔍 Trying to extract code from markdown content...');
    
    // Look for any remaining pre elements with cascade code
    const preElements = document.querySelectorAll('pre');
    for (let pre of preElements) {
      const code = pre.querySelector('code');
      if (code && (code.className.includes('cascade') || code.className.includes('language-cascade'))) {
        const codeText = code.textContent || code.innerText;
        console.log('🔍 Found cascade code in pre element:', codeText.substring(0, 100) + '...');
        return codeText;
      }
    }
    
    // Look for script elements or other containers that might have the code
    const allCodeElements = document.querySelectorAll('code');
    for (let code of allCodeElements) {
      const codeText = code.textContent || code.innerText;
      if (codeText.includes('function buildModel') && codeText.includes('oc')) {
        console.log('🔍 Found buildModel function in code element:', codeText.substring(0, 100) + '...');
        return codeText;
      }
    }
    
    console.log('🔍 No cascade code found in markdown content');
    return null;
  },
  
  // Undo editor changes (revert to last RUN state)
  undoEditorChanges: function(containerId) {
    if (!this.aceEditors[containerId]) {
      console.error('❌ No editor found for:', containerId);
      return;
    }
    
    if (!this.editorVersions || !this.editorVersions[containerId] || !this.editorVersions[containerId].lastRunCode) {
      console.log('⚠️ No previous RUN state to undo to for:', containerId);
      this.updateStatus(containerId, 'No previous run state to undo to', 'warning', 3000);
      return;
    }
    
    const lastRunCode = this.editorVersions[containerId].lastRunCode;
    this.aceEditors[containerId].setValue(lastRunCode, -1);
    this.hideErrorDisplay(containerId);
    
    // Update status
    this.updateStatus(containerId, 'Changes undone to last run state', 'success', 2500);
    
    console.log('↶ Undid changes to last RUN state for:', containerId);
  },
  
  // Reset editor to original code
  resetEditorCode: function(containerId) {
    if (!this.aceEditors[containerId]) {
      console.error('❌ No editor found for:', containerId);
      return;
    }
    
    // Get the original code from multiple sources
    let originalCode = null;
    
    // Try version tracking first
    if (this.editorVersions && this.editorVersions[containerId] && this.editorVersions[containerId].originalCode) {
      originalCode = this.editorVersions[containerId].originalCode;
    }
    
    // Fall back to the same logic as populateEditorWithCurrentCode
    if (!originalCode) {
      originalCode = this.currentModelData.originalCode || 
                    (window.cascadeOriginalCode && window.cascadeOriginalCode[containerId]) ||
                    this.extractCodeFromPage(containerId) || 
                    this.extractCodeFromMarkdown();
    }
    
    if (originalCode) {
      this.aceEditors[containerId].setValue(originalCode, -1);
      this.updateStatus(containerId, 'Code reset to original', 'success', 2500);
      console.log('🔄 Editor reset to original code for:', containerId);
    } else {
      // Fallback to repopulating
      this.populateEditorWithCurrentCode(containerId);
      this.updateStatus(containerId, 'Code reset using fallback method', 'warning', 3000);
      console.log('🔄 Editor reset using fallback method for:', containerId);
    }
    
    this.hideErrorDisplay(containerId);
  },
  
  // Run code from editor
  runCodeFromEditor: function(containerId) {
    console.log('▶️ Running code from editor for:', containerId);
    
    if (!this.aceEditors[containerId]) {
      console.error('❌ No editor found for:', containerId);
      return;
    }
    
    const code = this.aceEditors[containerId].getValue();
    
    // Save current state for UNDO functionality
    if (this.editorVersions && this.editorVersions[containerId]) {
      this.editorVersions[containerId].lastRunCode = code;
      console.log('💾 Saved current code state for UNDO');
    }
    
    this.hideErrorDisplay(containerId);
    
    // Execute the code
    window.ocjsReady.then(oc => {
      try {
        // Create a function wrapper and execute the code
        const functionWrapper = `
          (function(oc) {
            ${code}
            
            // Expect a buildModel function to be defined
            if (typeof buildModel === 'function') {
              return buildModel(oc);
            } else {
              throw new Error('Code must define a buildModel(oc) function that returns a shape');
            }
          })
        `;
        
        console.log('🔧 Executing edited code...');
        const executeCode = eval(functionWrapper);
        const shape = executeCode(oc);
        
        if (shape) {
          console.log('✅ Code executed successfully, updating model...');
          
          // Store the new code
          this.currentModelData.originalCode = code;
          
          // Update the 3D viewer with the new model
          this.displayModel(shape, containerId);
          
          // Update status
          this.updateStatus(containerId, 'Code executed successfully - Model updated', 'success', 3000);
          
          console.log('✅ Model updated successfully!');
        } else {
          throw new Error('buildModel function did not return a valid shape');
        }
        
      } catch (error) {
        console.error('❌ Error executing code:', error);
        this.showErrorDisplay(containerId, error.message);
        
        // Update status with error
        this.updateStatus(containerId, `Code execution failed: ${error.message}`, 'error', 0);
      }
    }).catch(error => {
      console.error('❌ OpenCascade.js not ready:', error);
      this.showErrorDisplay(containerId, 'OpenCascade.js is not ready yet. Please wait and try again.');
      
      // Update status with error
      this.updateStatus(containerId, 'OpenCascade.js not ready - Please wait and try again', 'error', 0);
    });
  },
  
  // Show error in the error display area
  showErrorDisplay: function(containerId, errorMessage) {
    const errorDisplay = document.getElementById(containerId + '-error-display');
    const errorMessageEl = document.getElementById(containerId + '-error-message');
    
    if (errorDisplay && errorMessageEl) {
      errorMessageEl.textContent = errorMessage;
      errorDisplay.style.display = 'block';
    }
  },
  
  // Hide error display
  hideErrorDisplay: function(containerId) {
    const errorDisplay = document.getElementById(containerId + '-error-display');
    if (errorDisplay) {
      errorDisplay.style.display = 'none';
    }
  },
  
  // Status notification system
  updateStatus: function(containerId, message, type = 'success', duration = 3000) {
    console.log(`📢 Status Update [${type}]:`, message);
    
    // Find or create status container
    let statusContainer = document.getElementById(containerId + '-status-container');
    
    if (!statusContainer) {
      // Create status container if it doesn't exist
      statusContainer = document.createElement('div');
      statusContainer.id = containerId + '-status-container';
      statusContainer.style.cssText = 'margin: 10px 0; text-align: center;';
      
      // Insert after the buttons container (not the viewer)
      const buttonsContainer = document.getElementById(containerId + '-export-buttons');
      if (buttonsContainer && buttonsContainer.parentNode) {
        buttonsContainer.parentNode.insertBefore(statusContainer, buttonsContainer.nextSibling);
      } else {
        // Fallback: insert after viewer if buttons container not found
        const viewerContainer = document.getElementById(containerId);
        if (viewerContainer && viewerContainer.parentNode) {
          viewerContainer.parentNode.insertBefore(statusContainer, viewerContainer.nextSibling);
        }
      }
    }
    
    // Determine styling based on type
    let bgColor, borderColor, textColor, icon;
    switch (type) {
      case 'success':
        bgColor = '#d4edda';
        borderColor = '#c3e6cb';
        textColor = '#155724';
        icon = '✅';
        break;
      case 'error':
        bgColor = '#f8d7da';
        borderColor = '#f5c6cb';
        textColor = '#721c24';
        icon = '❌';
        break;
      case 'warning':
        bgColor = '#fff3cd';
        borderColor = '#ffeaa7';
        textColor = '#856404';
        icon = '⚠️';
        break;
      case 'info':
        bgColor = '#d1ecf1';
        borderColor = '#bee5eb';
        textColor = '#0c5460';
        icon = 'ℹ️';
        break;
      default:
        bgColor = '#e2e3e5';
        borderColor = '#d6d8db';
        textColor = '#383d41';
        icon = '📝';
    }
    
    // Create status message
    const timestamp = new Date().toLocaleTimeString();
    statusContainer.innerHTML = `
      <div style="padding: 10px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 4px; color: ${textColor}; font-size: 14px;">
        <span style="font-weight: bold;">${icon} ${message}</span>
        <span style="float: right; font-size: 12px; opacity: 0.7;">${timestamp}</span>
      </div>
    `;
    
    // Auto-hide after duration (unless it's an error)
    if (type !== 'error' && duration > 0) {
      setTimeout(() => {
        if (statusContainer && statusContainer.parentNode) {
          statusContainer.style.opacity = '0.5';
          setTimeout(() => {
            if (statusContainer && statusContainer.parentNode) {
              statusContainer.innerHTML = '';
            }
          }, 1000);
        }
      }, duration);
    }
  }
};

console.log('✅ Cascade viewer utilities loaded successfully!');

/**
 * Auto-detect and execute cascade code blocks
 */
window.cascadeViewer.autoDetectAndExecute = function() {
  // Wait for OpenCascade to be ready
  window.ocjsReady.then(oc => {
    console.log('🔍 Scanning for cascade code blocks...');
    
    // Find all code elements with language-cascade class
    const cascadeBlocks = document.querySelectorAll('code.language-cascade');
    
    if (cascadeBlocks.length === 0) {
      console.log('ℹ️ No cascade code blocks found on this page');
      return;
    }
    
    console.log(`🎯 Found ${cascadeBlocks.length} cascade code block(s)`);
    
    // Process each cascade block
    cascadeBlocks.forEach((codeBlock, index) => {
      // Get the code content (declare outside try block for error handler access)
      const codeContent = codeBlock.textContent || codeBlock.innerText;
      
      // Find the container for this code block (declare outside try block for error handler access)
      let containerId = 'viewer'; // default
      
      // Look for a viewer div near this code block
      let parent = codeBlock.parentElement;
      while (parent && parent !== document.body) {
        const viewerDiv = parent.querySelector('div[id*="viewer"]');
        if (viewerDiv) {
          containerId = viewerDiv.id;
          break;
        }
        parent = parent.parentElement;
      }
      
      try {
        console.log(`🚀 Processing cascade block ${index + 1}...`);
        console.log(`📝 Code content (${codeContent.length} chars):`, codeContent.substring(0, 100) + '...');
        console.log(`🎯 Found viewer container: ${containerId}`);
        
        // Create a function wrapper and execute the code
        const functionWrapper = `
          (function(oc) {
            ${codeContent}
            
            // Expect a buildModel function to be defined
            if (typeof buildModel === 'function') {
              return buildModel(oc);
            } else {
              throw new Error('cascade code block must define a buildModel(oc) function that returns a shape');
            }
          })
        `;
        
        console.log('🔧 Executing cascade code...');
        const executeCode = eval(functionWrapper);
        const shape = executeCode(oc);
        
        if (shape) {
          console.log('✅ Model built successfully, displaying...');
          
          // Replace the code block with a loading message
          const loadingDiv = document.createElement('div');
          loadingDiv.innerHTML = `
            <div style="padding: 20px; text-align: center; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; margin: 10px 0;">
              <p>🚀 <strong>Cascade Model ${index + 1}</strong></p>
              <p>Loading 3D viewer...</p>
            </div>
          `;
          
          // Find the pre element containing this code block and replace it
          let preElement = codeBlock.parentElement;
          while (preElement && preElement.tagName !== 'PRE') {
            preElement = preElement.parentElement;
          }
          
          if (preElement) {
            preElement.parentNode.replaceChild(loadingDiv, preElement);
          }
          
          // Store the original code for the editor
          this.currentModelData.originalCode = codeContent;
          console.log('📝 Stored original code for editor (' + codeContent.length + ' chars):', codeContent.substring(0, 100) + '...');
          
          // Also store it globally as a backup
          if (!window.cascadeOriginalCode) {
            window.cascadeOriginalCode = {};
          }
          window.cascadeOriginalCode[containerId] = codeContent;
          console.log('📝 Backup code stored globally for container:', containerId);
          
          // Display the model
          this.displayModel(shape, containerId);
          
          // Update status with new notification system
          setTimeout(() => {
            this.updateStatus(containerId, `Cascade Model ${index + 1} loaded successfully`, 'success', 4000);
            
            // Remove the loading div since we now use the status system
            if (loadingDiv && loadingDiv.parentNode) {
              loadingDiv.parentNode.removeChild(loadingDiv);
            }
          }, 1000);
          
        } else {
          throw new Error('buildModel function did not return a valid shape');
        }
        
      } catch (error) {
        console.error(`❌ Error processing cascade block ${index + 1}:`, error);
        
        // Store the original code for the editor (even on error)
        this.currentModelData.originalCode = codeContent;
        console.log('📝 Stored original code for editor after error (' + codeContent.length + ' chars)');
        
        // Also store it globally as a backup
        if (!window.cascadeOriginalCode) {
          window.cascadeOriginalCode = {};
        }
        window.cascadeOriginalCode[containerId] = codeContent;
        
        // Find the pre element containing this code block and hide it (don't replace with error div)
        let preElement = codeBlock.parentElement;
        while (preElement && preElement.tagName !== 'PRE') {
          preElement = preElement.parentElement;
        }
        
        if (preElement) {
          preElement.style.display = 'none';
        }
        
        // Create a minimal viewer container for the editor to attach to (no redundant message)
        const viewerDiv = document.createElement('div');
        viewerDiv.id = containerId;
        viewerDiv.style.cssText = 'width: 100%; height: 400px; max-width: 100%; margin: 10px auto; border: 1px solid #ccc; background: #f8f9fa; display: none;';
        
        // Insert the viewer container after the hidden pre element
        if (preElement && preElement.parentNode) {
          preElement.parentNode.insertBefore(viewerDiv, preElement.nextSibling);
        }
        
        // Automatically open the code editor after a short delay
        setTimeout(() => {
          console.log('🔧 Auto-opening editor due to code failure...');
          
          // Show export buttons (needed for editor to work)
          this.showExportButtons(containerId);
          
          // Show the code editor
          this.showCodeEditor(containerId);
          
          // Update status to indicate auto-opening (ephemeral notification)
          this.updateStatus(containerId, `Code failed: ${error.message} - Editor opened for debugging`, 'error', 0);
          
          // Show the error in the editor's error display as well (required by user)
          const errorDisplay = document.getElementById(containerId + '-error-display');
          const errorMessage = document.getElementById(containerId + '-error-message');
          if (errorDisplay && errorMessage) {
            errorMessage.textContent = `Error in cascade code:\n${error.message}\n\nStack trace:\n${error.stack || 'No stack trace available'}`;
            errorDisplay.style.display = 'block';
          }
          
        }, 500); // Small delay to ensure DOM is ready
      }
    });
    
  }).catch(error => {
    console.error('❌ Failed to initialize cascade auto-detection:', error);
  });
};

// Auto-run cascade detection when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.cascadeViewer.autoDetectAndExecute();
  });
} else {
  // DOM is already ready
  window.cascadeViewer.autoDetectAndExecute();
}

</script>

