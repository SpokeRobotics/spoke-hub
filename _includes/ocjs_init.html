{% comment %}
OpenCascade.js initialization include for Spoke documentation site.
Usage in any page:

  {% include ocjs_init.html container_id="my-viewer" %}

This include automatically creates a <div> with the specified container_id (default 'ocjs-viewer')
with responsive sizing and loads OpenCascade.js along with Three.js utilities.

After including this, you can:
1. Use window.ocjsReady Promise to access OpenCascade.js
2. Use window.cascadeViewer utilities for 3D visualization
3. Call window.cascadeViewer.displayModel(shape) to show any OpenCascade shape
{% endcomment %}

<!-- Viewer container -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}" style="width: 100%; height: 600px; max-width: 100%; margin: 0 auto; border: 1px solid #ccc;"></div>

<!-- Export buttons container (hidden by default) -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}-export-buttons" style="display: none; text-align: center; margin: 10px 0; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
  <!-- Edit button section -->
  <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6;">
    <p style="margin: 0 0 10px 0; font-weight: bold; color: #495057;">‚úèÔ∏è Edit Code:</p>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-edit-code" style="margin: 0 5px; padding: 8px 16px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">EDIT</button>
  </div>
  
  <!-- Export section -->
  <div>
    <p style="margin: 0 0 10px 0; font-weight: bold; color: #495057;">üìÅ Export Model:</p>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-step" style="margin: 0 5px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">STEP</button>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-stl" style="margin: 0 5px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">STL</button>
    <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-gltf" style="margin: 0 5px; padding: 8px 16px; background: #ffc107; color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">GLTF</button>
  </div>
</div>

<!-- Code editor container (hidden by default) -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}-editor-container" style="display: none; margin: 10px 0; border: 1px solid #dee2e6; border-radius: 4px; background: #f8f9fa;">
  <!-- Editor header -->
  <div style="padding: 10px; background: #e9ecef; border-bottom: 1px solid #dee2e6; border-radius: 4px 4px 0 0;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h4 style="margin: 0; color: #495057; font-size: 16px;">üõ†Ô∏è Edit Cascade Code</h4>
      <button id="{{ include.container_id | default: 'ocjs-viewer' }}-editor-close" style="background: #6c757d; color: white; border: none; border-radius: 3px; padding: 5px 10px; cursor: pointer; font-size: 12px;">‚úï Close</button>
    </div>
  </div>
  
  <!-- Editor content -->
  <div style="padding: 15px;">
    <!-- Ace Editor will be inserted here -->
    <div id="{{ include.container_id | default: 'ocjs-viewer' }}-ace-editor" style="width: 100%; height: 300px; border: 1px solid #ced4da; border-radius: 4px;"></div>
    
    <!-- Editor controls -->
    <div style="margin-top: 15px; display: flex; justify-content: space-between; align-items: center;">
      <div>
        <button id="{{ include.container_id | default: 'ocjs-viewer' }}-run-code" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 10px 20px; cursor: pointer; font-size: 14px; font-weight: bold;">‚ñ∂Ô∏è RUN</button>
        <button id="{{ include.container_id | default: 'ocjs-viewer' }}-reset-code" style="background: #6c757d; color: white; border: none; border-radius: 4px; padding: 10px 20px; cursor: pointer; font-size: 14px; margin-left: 10px;">üîÑ Reset</button>
      </div>
      <div style="font-size: 12px; color: #6c757d;">
        <kbd>Ctrl+Enter</kbd> to run
      </div>
    </div>
    
    <!-- Error display area -->
    <div id="{{ include.container_id | default: 'ocjs-viewer' }}-error-display" style="display: none; margin-top: 15px; padding: 15px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24;">
      <h5 style="margin: 0 0 10px 0; color: #721c24;">‚ùå Error</h5>
      <pre id="{{ include.container_id | default: 'ocjs-viewer' }}-error-message" style="margin: 0; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 13px;"></pre>
    </div>
  </div>
</div>

<!-- Import map for OpenCascade.js and Three.js ES modules -->
<script type="importmap">
{
  "imports": {
    "opencascade.js": "https://unpkg.com/opencascade.js@1.1.1/dist/opencascade.wasm.js",
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "ace-builds": "https://cdn.skypack.dev/ace-builds@1.32.6",
    "ace-builds/": "https://cdn.skypack.dev/ace-builds@1.32.6/"
  }
}
</script>

<!-- Load OpenCascade.js, Three.js utilities, and Ace Editor -->
<script type="module">
import initOpenCascade from 'opencascade.js';
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Import Ace Editor as ES module
import ace from 'ace-builds';
import 'ace-builds/src-noconflict/mode-javascript';
import 'ace-builds/src-noconflict/theme-monokai';

// Make ace globally available for the cascadeViewer
window.ace = ace;
console.log('‚úÖ Ace Editor loaded as ES module');

/**
 * window.ocjsReady is a Promise that resolves with the initialized OpenCascade.js module.
 */
window.ocjsReady = initOpenCascade({
  locateFile: function(path, prefix) {
    // Return the unpkg CDN path for WASM files
    if (path.endsWith('.wasm')) {
      return 'https://unpkg.com/opencascade.js@1.1.1/dist/' + path;
    }
    return prefix + path;
  }
}).then(oc => {
  console.log('OpenCascade.js loaded successfully from unpkg CDN');
  return oc;
}).catch(error => {
  console.error('Failed to load OpenCascade.js:', error);
  throw error;
});

/**
 * window.cascadeViewer provides utilities for CAD visualization
 */
window.cascadeViewer = {
  // Store current model data for export
  currentModelData: {
    shape: null,
    geometry: null,
    oc: null,
    containerId: null
  },

  // Show export buttons after successful model load
  showExportButtons: function(containerId) {
    const exportButtonsId = containerId + '-export-buttons';
    const exportButtons = document.getElementById(exportButtonsId);
    if (exportButtons) {
      exportButtons.style.display = 'block';
      console.log('‚úÖ Export buttons shown for container:', containerId);
    }
  },

  // Hide export buttons
  hideExportButtons: function(containerId) {
    const exportButtonsId = containerId + '-export-buttons';
    const exportButtons = document.getElementById(exportButtonsId);
    if (exportButtons) {
      exportButtons.style.display = 'none';
    }
  },

  // Setup export button event handlers
  setupExportHandlers: function(containerId) {
    const editBtn = document.getElementById(containerId + '-edit-code');
    const stepBtn = document.getElementById(containerId + '-export-step');
    const stlBtn = document.getElementById(containerId + '-export-stl');
    const gltfBtn = document.getElementById(containerId + '-export-gltf');

    if (editBtn) {
      editBtn.onclick = () => this.showCodeEditor(containerId);
    }
    if (stepBtn) {
      stepBtn.onclick = () => this.exportSTEP();
    }
    if (stlBtn) {
      stlBtn.onclick = () => this.exportSTL();
    }
    if (gltfBtn) {
      gltfBtn.onclick = () => this.exportGLTF();
    }
    console.log('‚úÖ Export and edit button handlers setup for container:', containerId);
  },

  // Get page name for filename
  getPageName: function() {
    // Try to get page name from title, URL, or fallback to 'model'
    let pageName = 'model';
    
    // First try document title
    if (document.title) {
      pageName = document.title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
        .replace(/\s+/g, '-') // Replace spaces with hyphens
        .replace(/-+/g, '-') // Replace multiple hyphens with single
        .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
    }
    
    // Fallback to pathname if title is empty or generic
    if (!pageName || pageName === 'model' || pageName.length < 2) {
      const pathname = window.location.pathname;
      const pathParts = pathname.split('/').filter(part => part.length > 0);
      if (pathParts.length > 0) {
        pageName = pathParts[pathParts.length - 1]
          .replace(/\.html?$/, '') // Remove .html extension
          .replace(/[^a-z0-9-]/g, '') // Keep only alphanumeric and hyphens
          .toLowerCase();
      }
    }
    
    return pageName || 'model';
  },

  // Export functions (dummy implementations for now)
  exportSTEP: function() {
    console.log('üìÅ Exporting STEP file...');
    const filename = this.getPageName() + '.step';
    
    if (!this.currentModelData.shape || !this.currentModelData.oc) {
      console.error('‚ùå No OpenCascade shape data available for STEP export');
      alert('Error: No OpenCascade model data available for STEP export');
      return;
    }
    
    try {
      const oc = this.currentModelData.oc;
      const shape = this.currentModelData.shape;
      
      console.log('üîß Creating STEP writer...');
      const writer = new oc.STEPControl_Writer_1();
      
      console.log('üì¶ Transferring shape to STEP format...');
      writer.Transfer(
        shape,
        oc.STEPControl_StepModelType.STEPControl_AsIs,
        true
      );
      
      console.log('üíæ Writing STEP file...');
      // Use the exact filename that worked in our experimental function
      const tempFilename = 'test.step';
      writer.Write(tempFilename);
      
      console.log('üìñ Reading STEP content...');
      // Use the exact approach that worked: direct filename, no path prefix
      const stepContent = oc.FS.readFile(tempFilename, { encoding: 'utf8' });
      
      console.log('üìÅ Downloading STEP file...');
      this.downloadFile(filename, stepContent, 'application/step');
      
      console.log('‚úÖ STEP export completed:', filename, `(${stepContent.length} bytes)`);
      
    } catch (error) {
      console.error('‚ùå Error exporting STEP:', error);
      alert('Error exporting STEP file: ' + error.message);
    }
  },

  exportSTL: function() {
    console.log('üìÅ Exporting STL file...');
    const filename = this.getPageName() + '.stl';
    
    if (!this.currentModelData.geometry) {
      console.error('‚ùå No geometry data available for STL export');
      alert('Error: No model data available for export');
      return;
    }
    
    try {
      const stlContent = this.generateSTLContent(this.currentModelData.geometry);
      this.downloadFile(filename, stlContent, 'model/stl');
      console.log('‚úÖ STL file exported successfully:', filename);
    } catch (error) {
      console.error('‚ùå Error exporting STL:', error);
      alert('Error exporting STL file: ' + error.message);
    }
  },

  exportGLTF: function() {
    console.log('üìÅ Exporting GLTF file...');
    const filename = this.getPageName() + '.gltf';
    
    if (!this.currentModelData.geometry) {
      console.error('‚ùå No geometry data available for GLTF export');
      alert('Error: No model data available for export');
      return;
    }
    
    try {
      this.generateGLTFContent(this.currentModelData.geometry, filename);
      console.log('‚úÖ GLTF export initiated:', filename);
    } catch (error) {
      console.error('‚ùå Error exporting GLTF:', error);
      alert('Error exporting GLTF file: ' + error.message);
    }
  },

  // Helper function to download dummy files
  downloadDummyFile: function(filename, content) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log('‚úÖ Downloaded dummy file:', filename);
  },

  // Helper function to download files with proper MIME types
  downloadFile: function(filename, content, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log('‚úÖ Downloaded file:', filename);
  },

  // Generate STL content from Three.js geometry
  generateSTLContent: function(geometry) {
    console.log('üîß Generating STL content from geometry...');
    
    const vertices = geometry.attributes.position.array;
    const indices = geometry.index ? geometry.index.array : null;
    const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
    
    let stlContent = 'solid OpenCascadeModel\n';
    
    // If geometry is indexed, use indices to create triangles
    if (indices) {
      for (let i = 0; i < indices.length; i += 3) {
        const i1 = indices[i] * 3;
        const i2 = indices[i + 1] * 3;
        const i3 = indices[i + 2] * 3;
        
        // Get vertices
        const v1 = [vertices[i1], vertices[i1 + 1], vertices[i1 + 2]];
        const v2 = [vertices[i2], vertices[i2 + 1], vertices[i2 + 2]];
        const v3 = [vertices[i3], vertices[i3 + 1], vertices[i3 + 2]];
        
        // Calculate normal if not provided
        let normal;
        if (normals) {
          normal = [normals[i1], normals[i1 + 1], normals[i1 + 2]];
        } else {
          // Calculate normal from cross product
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          // Normalize
          const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
        }
        
        stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
        stlContent += '    outer loop\n';
        stlContent += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
        stlContent += '    endloop\n';
        stlContent += '  endfacet\n';
      }
    } else {
      // Non-indexed geometry - process vertices in groups of 3
      for (let i = 0; i < vertices.length; i += 9) {
        const v1 = [vertices[i], vertices[i + 1], vertices[i + 2]];
        const v2 = [vertices[i + 3], vertices[i + 4], vertices[i + 5]];
        const v3 = [vertices[i + 6], vertices[i + 7], vertices[i + 8]];
        
        // Calculate normal
        let normal;
        if (normals) {
          normal = [normals[i], normals[i + 1], normals[i + 2]];
        } else {
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
        }
        
        stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
        stlContent += '    outer loop\n';
        stlContent += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
        stlContent += '    endloop\n';
        stlContent += '  endfacet\n';
      }
    }
    
    stlContent += 'endsolid OpenCascadeModel\n';
    
    console.log(`‚úÖ Generated STL with ${indices ? indices.length / 3 : vertices.length / 9} triangles`);
    return stlContent;
  },

  // Generate GLTF content from Three.js geometry
  generateGLTFContent: function(geometry, filename) {
    console.log('üîß Generating GLTF content from geometry...');
    
    // Create a temporary scene with the geometry
    const scene = new THREE.Scene();
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x888888,
      metalness: 0.1,
      roughness: 0.8,
      opacity: 0.9
    });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    
    // Use GLTFExporter to export the scene
    const exporter = new GLTFExporter();
    
    exporter.parse(
      scene,
      (gltfData) => {
        console.log('‚úÖ GLTF data generated successfully');
        
        // Convert to JSON string for text-based GLTF format
        const gltfString = JSON.stringify(gltfData, null, 2);
        
        // Download the GLTF file
        this.downloadFile(filename, gltfString, 'model/gltf+json');
        console.log(`‚úÖ GLTF file exported successfully: ${filename}`);
      },
      (error) => {
        console.error('‚ùå Error generating GLTF:', error);
        throw new Error('Failed to generate GLTF data: ' + error.message);
      },
      {
        binary: false, // Export as text-based GLTF, not GLB
        embedImages: true,
        truncateDrawRange: true
      }
    );
  },


  // Convert OpenCascade shape to Three.js mesh data
  convertOpenCascadeToMesh: function(shape, oc) {
    console.log('üîß Converting OpenCascade shape to mesh...');
    
    try {
      // Use OpenCascade's meshing capabilities
      console.log('üîß Creating mesher...');
      const mesher = new oc.BRepMesh_IncrementalMesh_2(shape, 0.1, false, 0.5, false);
      console.log('üîß Performing mesh operation...');
      mesher.Perform();
      
      if (!mesher.IsDone()) {
        throw new Error('Failed to mesh the OpenCascade shape');
      }
      console.log('‚úÖ Meshing completed successfully');
      
      const vertices = [];
      const indices = [];
      const normals = [];
      
      // Iterate through faces to extract mesh data
      console.log('üîç Exploring faces...');
      const faceExplorer = new oc.TopExp_Explorer_2(shape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);
      
      let vertexOffset = 0;
      let faceCount = 0;
      
      while (faceExplorer.More()) {
        faceCount++;
        
        const face = oc.TopoDS.Face_1(faceExplorer.Current());
        const location = new oc.TopLoc_Location_1();
        const triangulation = oc.BRep_Tool.Triangulation(face, location);
        
        if (!triangulation.IsNull()) {
          // console.log(`  Face ${faceCount} has triangulation data`);
          const transform = location.Transformation();
          
          // Get node and triangle counts using correct API
          const nodeCount = triangulation.get().NbNodes();
          const triangleCount = triangulation.get().NbTriangles();
          
          // Extract vertices
          for (let i = 1; i <= nodeCount; i++) {
            const node = triangulation.get().Node(i);
            const transformedNode = node.Transformed(transform);
            vertices.push(transformedNode.X(), transformedNode.Y(), transformedNode.Z());
          }
          
          // Process each triangle in the face with corrected orientation
          for (let t = 1; t <= triangleCount; t++) {
            const triangle = triangulation.get().Triangle(t);
            const n1 = triangle.Value(1);
            const n2 = triangle.Value(2);
            const n3 = triangle.Value(3);
            
            // Get triangle vertices
            const v1 = triangulation.get().Node(n1).Transformed(transform);
            const v2 = triangulation.get().Node(n2).Transformed(transform);
            const v3 = triangulation.get().Node(n3).Transformed(transform);
            
            // Compute triangle normal using cross product
            const edge1 = new THREE.Vector3(
              v2.X() - v1.X(),
              v2.Y() - v1.Y(),
              v2.Z() - v1.Z()
            );
            const edge2 = new THREE.Vector3(
              v3.X() - v1.X(),
              v3.Y() - v1.Y(),
              v3.Z() - v1.Z()
            );
            
            let normal = edge1.cross(edge2).normalize();
            
            // Get face orientation from OpenCascade
            const faceOrientation = face.Orientation_1();
            
            // Check if face is reversed according to OpenCascade
            const isReversed = (faceOrientation === oc.TopAbs_Orientation.TopAbs_REVERSED);
            
            if (isReversed) {
              // Face is reversed, flip normal and triangle winding
              normal.negate();
              indices.push(
                vertexOffset + n1 - 1,
                vertexOffset + n3 - 1,  // Swapped n2 and n3 for reversed winding
                vertexOffset + n2 - 1
              );
            } else {
              // Face is forward, keep original normal and winding
              indices.push(
                vertexOffset + n1 - 1,
                vertexOffset + n2 - 1,
                vertexOffset + n3 - 1
              );
            }
            
            // Add the corrected normal for all three vertices of the triangle
            for (let j = 0; j < 3; j++) {
              normals.push(normal.x, normal.y, normal.z);
            }
          }
          
          vertexOffset += nodeCount;
        } else {
          console.log(`  Face ${faceCount} has no triangulation data`);
        }
        
        faceExplorer.Next();
      }
      
      console.log(`üîç Extracted ${vertices.length / 3} vertices, ${indices.length / 3} triangles from ${faceCount} faces`);
      
      if (vertices.length === 0) {
        throw new Error('No vertices extracted from OpenCascade shape');
      }
      
      // Create Three.js geometry
      console.log('üîß Creating Three.js BufferGeometry...');
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geometry.setIndex(indices);
      
      console.log('‚úÖ Three.js geometry created successfully');
      return geometry;
      
    } catch (error) {
      console.error('‚ùå Error in convertOpenCascadeToMesh:', error);
      throw error;
    }
  },

  // Export geometry to GLB format
  exportToGLB: function(geometry) {
    return new Promise((resolve, reject) => {
      console.log('üì¶ Exporting geometry to GLB...');
      
      try {
        const material = new THREE.MeshStandardMaterial({ 
          color: 0x808080,
          metalness: 0.1,
          roughness: 0.4,
          transparent: false,
          opacity: 1.0
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        const scene = new THREE.Scene();
        scene.add(mesh);
        
        console.log('üì¶ Creating GLTFExporter...');
        const exporter = new GLTFExporter();
        exporter.parse(
          scene,
          (gltf) => {
            console.log('‚úÖ GLB export successful, size:', gltf.byteLength, 'bytes');
            resolve(gltf);
          },
          (error) => {
            console.error('‚ùå GLB export failed:', error);
            reject(error);
          },
          { binary: true }
        );
      } catch (error) {
        console.error('‚ùå Error setting up GLB export:', error);
        reject(error);
      }
    });
  },

  // Load GLB and display in Three.js viewer
  loadGLBAndDisplay: function(glbData, containerId = 'viewer') {
    console.log('üé¨ Loading GLB data into Three.js viewer...');
    
    const container = document.getElementById(containerId);
    
    // === Initialize Three.js Scene ===
    console.log('üé¨ Initializing Three.js scene...');
    
    if (!container) {
      console.error('‚ùå Viewer container not found');
      return;
    }
    
    // Clear previous content to prevent WebGL context conflicts
    container.innerHTML = '';
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    
    // Create camera with proper aspect ratio
    const containerRect = container.getBoundingClientRect();
    const camera = new THREE.PerspectiveCamera(
      75, 
      containerRect.width / containerRect.height, 
      0.1, 
      1000
    );
    
    // Position camera for good viewing angle
    camera.position.set(80, 60, 80);
    camera.lookAt(24, 16, 18);
    
    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRect.width, containerRect.height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Append renderer to cleared container
    container.appendChild(renderer.domElement);
    
    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(24, 16, 18);
    controls.update();
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Load the GLB data
    console.log('üì¶ Loading GLB data...');
    const loader = new GLTFLoader();
    const blob = new Blob([glbData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    
    loader.load(
      url,
      (gltf) => {
        console.log('‚úÖ GLB loaded successfully');
        const model = gltf.scene;
        
        scene.add(model);
        console.log('‚úÖ Model added to scene');
        
        // Add wireframe overlay
        model.traverse((child) => {
          if (child.isMesh) {
            const wireframe = new THREE.WireframeGeometry(child.geometry);
            const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
              color: 0xFFFFFF, 
              opacity: 0.3, 
              transparent: true 
            }));
            scene.add(line);
            
            // Store references for animation
            window.cadModel = model;
            window.cadWireframe = line;
            console.log('‚úÖ Wireframe overlay added');
          }
        });
        
        // Clean up blob URL
        URL.revokeObjectURL(url);
        
        console.log('‚úÖ Model setup completed successfully!');
        
        // Show export buttons and setup handlers after successful load
        window.cascadeViewer.setupExportHandlers(containerId);
        window.cascadeViewer.showExportButtons(containerId);
      },
      (progress) => {
        console.log('üìä Loading progress:', progress);
      },
      (error) => {
        console.error('‚ùå Error loading GLB:', error);
        URL.revokeObjectURL(url);
      }
    );
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Rotate the CAD model and wireframe if they exist
      if (window.cadModel && window.cadWireframe) {
        window.cadModel.rotation.x += 0.005;
        window.cadModel.rotation.y += 0.005;
        window.cadWireframe.rotation.x += 0.005;
        window.cadWireframe.rotation.y += 0.005;
      }
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
    console.log('üé¨ Animation loop started');
  },

  // Fallback: Direct Three.js visualization (skip GLB export/import)
  directThreeJSVisualization: function(geometry, containerId = 'viewer') {
    console.log('üéØ Using direct Three.js visualization fallback...');
    
    const container = document.getElementById(containerId);
    
    // Check if a renderer already exists and dispose of it properly
    if (window.threeJSRenderer) {
      console.log('üßπ Disposing existing Three.js renderer');
      window.threeJSRenderer.dispose();
      window.threeJSRenderer = null;
    }
    
    // Clear any existing content completely
    container.innerHTML = '';
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(100, 100, 100);
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false,
      preserveDrawingBuffer: false,
      powerPreference: "high-performance"
    });
    
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Store renderer globally for cleanup
    window.threeJSRenderer = renderer;
    
    // Add renderer canvas to container
    container.appendChild(renderer.domElement);
    
    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Create mesh from OpenCascade-derived geometry
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      metalness: 0.1,
      roughness: 0.4,
      transparent: true,
      opacity: 0.9
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    
    // Add wireframe overlay
    const wireframe = new THREE.WireframeGeometry(geometry);
    const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
      color: 0x000000, 
      opacity: 0.3, 
      transparent: true 
    }));
    scene.add(line);
    
    // Store references for animation
    window.cadModel = mesh;
    window.cadWireframe = line;
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      mesh.rotation.x += 0.005;
      mesh.rotation.y += 0.005;
      line.rotation.x += 0.005;
      line.rotation.y += 0.005;
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
    console.log('‚úÖ Direct Three.js visualization completed successfully!');
    
    // Show export buttons and setup handlers after successful fallback load
    this.setupExportHandlers(containerId);
    this.showExportButtons(containerId);
  },

  // Main function to display any OpenCascade shape
  displayModel: async function(shape, containerId = 'viewer') {
    try {
      console.log('üöÄ Starting OpenCascade.js ‚Üí GLB ‚Üí Three.js workflow...');
      
      const oc = await window.ocjsReady;
      
      // Store model data for export
      this.currentModelData = {
        shape: shape,
        geometry: null,
        oc: oc,
        containerId: containerId
      };
      
      // Hide export buttons initially
      this.hideExportButtons(containerId);
      
      // Step 1: Convert OpenCascade shape to Three.js geometry
      console.log('üîß Step 1: Converting OpenCascade shape to mesh...');
      const geometry = this.convertOpenCascadeToMesh(shape, oc);
      
      // Store geometry for export
      this.currentModelData.geometry = geometry;
      
      // Try GLB workflow first
      try {
        console.log('üì¶ Step 2: Attempting GLB export/import workflow...');
        // Step 2: Export geometry to GLB
        const glbData = await this.exportToGLB(geometry);
        
        // Step 3: Load GLB and display in Three.js
        this.loadGLBAndDisplay(glbData, containerId);
        
        console.log('‚úÖ CAD viewer GLB workflow completed successfully!');
        
      } catch (glbError) {
        console.warn('‚ö†Ô∏è GLB workflow failed, falling back to direct visualization:', glbError);
        
        // Fallback: Direct Three.js visualization
        this.directThreeJSVisualization(geometry, containerId);
        
        console.log('‚úÖ CAD viewer fallback workflow completed successfully!');
      }
      
    } catch (error) {
      console.error('‚ùå Error in CAD viewer workflow:', error);
      
      // Ultimate fallback display
      const container = document.getElementById(containerId);
      container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f0f0f0; color: #333; font-family: Arial, sans-serif;">
          <div style="text-align: center;">
            <h3>üîß OpenCascade.js ‚Üí Three.js Workflow</h3>
            <p>OpenCascade shape created successfully!</p>
            <p><em>‚ö†Ô∏è 3D viewer encountered an error during processing. Check console for details.</em></p>
            <p><strong>Error:</strong> ${error.message}</p>
          </div>
        </div>
      `;
    }
  },

  // Show code editor for editing cascade code
  showCodeEditor: function(containerId) {
    console.log('‚úèÔ∏è Opening code editor for container:', containerId);
    
    // Show the editor container
    const editorContainer = document.getElementById(containerId + '-editor-container');
    if (!editorContainer) {
      console.error('‚ùå Editor container not found for:', containerId);
      return;
    }
    
    editorContainer.style.display = 'block';
    
    // Initialize Ace Editor if not already done
    const aceEditorId = containerId + '-ace-editor';
    if (!this.aceEditors) {
      this.aceEditors = {};
    }
    
    if (!this.aceEditors[containerId]) {
      console.log('üîß Initializing Ace Editor for:', containerId);
      
      // Check if Ace Editor is available (should be loaded as ES module)
      if (typeof window.ace === 'undefined') {
        console.error('‚ùå Ace Editor ES module not loaded');
        alert('Code editor failed to load. Please refresh the page and try again.');
        return;
      }
      
      // Create the editor
      const editor = window.ace.edit(aceEditorId);
      editor.setTheme('ace/theme/monokai');
      editor.session.setMode('ace/mode/javascript');
      editor.setOptions({
        fontSize: 14,
        showPrintMargin: false,
        wrap: true,
        enableBasicAutocompletion: true,
        enableLiveAutocompletion: true
      });
      
      // Add keyboard shortcut for running code (Ctrl+Enter)
      editor.commands.addCommand({
        name: 'runCode',
        bindKey: {win: 'Ctrl-Enter', mac: 'Cmd-Enter'},
        exec: () => this.runCodeFromEditor(containerId)
      });
      
      this.aceEditors[containerId] = editor;
      
      // Setup button handlers
      this.setupEditorHandlers(containerId);
    }
    
    // Populate editor with current code
    this.populateEditorWithCurrentCode(containerId);
    
    // Focus the editor
    setTimeout(() => {
      this.aceEditors[containerId].focus();
    }, 100);
    
    console.log('‚úÖ Code editor opened for:', containerId);
  },
  
  // Setup editor button handlers
  setupEditorHandlers: function(containerId) {
    const runBtn = document.getElementById(containerId + '-run-code');
    const resetBtn = document.getElementById(containerId + '-reset-code');
    const closeBtn = document.getElementById(containerId + '-editor-close');
    
    if (runBtn) {
      runBtn.onclick = () => this.runCodeFromEditor(containerId);
    }
    if (resetBtn) {
      resetBtn.onclick = () => this.resetEditorCode(containerId);
    }
    if (closeBtn) {
      closeBtn.onclick = () => this.closeCodeEditor(containerId);
    }
  },
  
  // Close code editor
  closeCodeEditor: function(containerId) {
    const editorContainer = document.getElementById(containerId + '-editor-container');
    if (editorContainer) {
      editorContainer.style.display = 'none';
    }
    this.hideErrorDisplay(containerId);
    console.log('‚úÖ Code editor closed for:', containerId);
  },
  
  // Populate editor with current cascade code
  populateEditorWithCurrentCode: function(containerId) {
    if (!this.aceEditors[containerId]) return;
    
    console.log('üîç Populating editor with code for:', containerId);
    console.log('üîç Stored originalCode:', this.currentModelData.originalCode ? this.currentModelData.originalCode.substring(0, 100) + '...' : 'null');
    
    // Try multiple sources for the code
    let currentCode = this.currentModelData.originalCode || 
                     (window.cascadeOriginalCode && window.cascadeOriginalCode[containerId]) ||
                     this.extractCodeFromPage(containerId) || 
                     this.extractCodeFromMarkdown();
    
    console.log('üîç Code sources checked:');
    console.log('  - currentModelData.originalCode:', this.currentModelData.originalCode ? 'found' : 'null');
    console.log('  - global backup:', window.cascadeOriginalCode && window.cascadeOriginalCode[containerId] ? 'found' : 'null');
    console.log('  - page extraction: will try if needed');
    console.log('  - markdown extraction: will try if needed');
    
    console.log('üîç Final code source:', currentCode ? currentCode.substring(0, 100) + '...' : 'using default template');
    
    if (!currentCode) {
      // Provide a default template
      currentCode = `function buildModel(oc) {
  // Create your OpenCascade.js model here
  // Example: Simple box
  const box = new oc.BRepPrimAPI_MakeBox_2(50, 50, 50);
  return box.Shape();
}`;
      console.log('‚ö†Ô∏è Using default template - original code not found');
    }
    
    this.aceEditors[containerId].setValue(currentCode, -1);
    console.log('‚úÖ Editor populated with code for:', containerId);
  },
  
  // Extract code from the current page (fallback)
  extractCodeFromPage: function(containerId) {
    console.log('üîç Trying to extract code from page...');
    // Try to find cascade code blocks on the page
    const codeBlocks = document.querySelectorAll('code.language-cascade');
    console.log('üîç Found', codeBlocks.length, 'cascade code blocks');
    if (codeBlocks.length > 0) {
      const code = codeBlocks[0].textContent || codeBlocks[0].innerText;
      console.log('üîç Extracted code from page:', code.substring(0, 100) + '...');
      return code;
    }
    return null;
  },
  
  // Extract code from markdown content (better fallback)
  extractCodeFromMarkdown: function() {
    console.log('üîç Trying to extract code from markdown content...');
    
    // Look for any remaining pre elements with cascade code
    const preElements = document.querySelectorAll('pre');
    for (let pre of preElements) {
      const code = pre.querySelector('code');
      if (code && (code.className.includes('cascade') || code.className.includes('language-cascade'))) {
        const codeText = code.textContent || code.innerText;
        console.log('üîç Found cascade code in pre element:', codeText.substring(0, 100) + '...');
        return codeText;
      }
    }
    
    // Look for script elements or other containers that might have the code
    const allCodeElements = document.querySelectorAll('code');
    for (let code of allCodeElements) {
      const codeText = code.textContent || code.innerText;
      if (codeText.includes('function buildModel') && codeText.includes('oc')) {
        console.log('üîç Found buildModel function in code element:', codeText.substring(0, 100) + '...');
        return codeText;
      }
    }
    
    console.log('üîç No cascade code found in markdown content');
    return null;
  },
  
  // Reset editor to original code
  resetEditorCode: function(containerId) {
    this.populateEditorWithCurrentCode(containerId);
    this.hideErrorDisplay(containerId);
    console.log('‚úÖ Editor code reset for:', containerId);
  },
  
  // Run code from editor
  runCodeFromEditor: function(containerId) {
    console.log('‚ñ∂Ô∏è Running code from editor for:', containerId);
    
    if (!this.aceEditors[containerId]) {
      console.error('‚ùå No editor found for:', containerId);
      return;
    }
    
    const code = this.aceEditors[containerId].getValue();
    this.hideErrorDisplay(containerId);
    
    // Execute the code
    window.ocjsReady.then(oc => {
      try {
        // Create a function wrapper and execute the code
        const functionWrapper = `
          (function(oc) {
            ${code}
            
            // Expect a buildModel function to be defined
            if (typeof buildModel === 'function') {
              return buildModel(oc);
            } else {
              throw new Error('Code must define a buildModel(oc) function that returns a shape');
            }
          })
        `;
        
        console.log('üîß Executing edited code...');
        const executeCode = eval(functionWrapper);
        const shape = executeCode(oc);
        
        if (shape) {
          console.log('‚úÖ Code executed successfully, updating model...');
          
          // Store the new code
          this.currentModelData.originalCode = code;
          
          // Update the 3D viewer with the new model
          this.displayModel(shape, containerId);
          
          console.log('‚úÖ Model updated successfully!');
        } else {
          throw new Error('buildModel function did not return a valid shape');
        }
        
      } catch (error) {
        console.error('‚ùå Error executing code:', error);
        this.showErrorDisplay(containerId, error.message);
      }
    }).catch(error => {
      console.error('‚ùå OpenCascade.js not ready:', error);
      this.showErrorDisplay(containerId, 'OpenCascade.js is not ready yet. Please wait and try again.');
    });
  },
  
  // Show error in the error display area
  showErrorDisplay: function(containerId, errorMessage) {
    const errorDisplay = document.getElementById(containerId + '-error-display');
    const errorMessageEl = document.getElementById(containerId + '-error-message');
    
    if (errorDisplay && errorMessageEl) {
      errorMessageEl.textContent = errorMessage;
      errorDisplay.style.display = 'block';
    }
  },
  
  // Hide error display
  hideErrorDisplay: function(containerId) {
    const errorDisplay = document.getElementById(containerId + '-error-display');
    if (errorDisplay) {
      errorDisplay.style.display = 'none';
    }
  }
};

console.log('‚úÖ Cascade viewer utilities loaded successfully!');

/**
 * Auto-detect and execute cascade code blocks
 */
window.cascadeViewer.autoDetectAndExecute = function() {
  // Wait for OpenCascade to be ready
  window.ocjsReady.then(oc => {
    console.log('üîç Scanning for cascade code blocks...');
    
    // Find all code elements with language-cascade class
    const cascadeBlocks = document.querySelectorAll('code.language-cascade');
    
    if (cascadeBlocks.length === 0) {
      console.log('‚ÑπÔ∏è No cascade code blocks found on this page');
      return;
    }
    
    console.log(`üéØ Found ${cascadeBlocks.length} cascade code block(s)`);
    
    // Process each cascade block
    cascadeBlocks.forEach((codeBlock, index) => {
      try {
        console.log(`üöÄ Processing cascade block ${index + 1}...`);
        
        // Get the code content
        const codeContent = codeBlock.textContent || codeBlock.innerText;
        console.log(`üìù Code content (${codeContent.length} chars):`, codeContent.substring(0, 100) + '...');
        
        // Find the container for this code block (look for nearby viewer divs)
        let containerId = 'viewer'; // default
        
        // Look for a viewer div near this code block
        let parent = codeBlock.parentElement;
        while (parent && parent !== document.body) {
          const viewerDiv = parent.querySelector('div[id*="viewer"]');
          if (viewerDiv) {
            containerId = viewerDiv.id;
            console.log(`üéØ Found viewer container: ${containerId}`);
            break;
          }
          parent = parent.parentElement;
        }
        
        // Create a function wrapper and execute the code
        const functionWrapper = `
          (function(oc) {
            ${codeContent}
            
            // Expect a buildModel function to be defined
            if (typeof buildModel === 'function') {
              return buildModel(oc);
            } else {
              throw new Error('cascade code block must define a buildModel(oc) function that returns a shape');
            }
          })
        `;
        
        console.log('üîß Executing cascade code...');
        const executeCode = eval(functionWrapper);
        const shape = executeCode(oc);
        
        if (shape) {
          console.log('‚úÖ Model built successfully, displaying...');
          
          // Replace the code block with a loading message
          const loadingDiv = document.createElement('div');
          loadingDiv.innerHTML = `
            <div style="padding: 20px; text-align: center; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; margin: 10px 0;">
              <p>üöÄ <strong>Cascade Model ${index + 1}</strong></p>
              <p>Loading 3D viewer...</p>
            </div>
          `;
          
          // Find the pre element containing this code block and replace it
          let preElement = codeBlock.parentElement;
          while (preElement && preElement.tagName !== 'PRE') {
            preElement = preElement.parentElement;
          }
          
          if (preElement) {
            preElement.parentNode.replaceChild(loadingDiv, preElement);
          }
          
          // Store the original code for the editor
          this.currentModelData.originalCode = codeContent;
          console.log('üìù Stored original code for editor (' + codeContent.length + ' chars):', codeContent.substring(0, 100) + '...');
          
          // Also store it globally as a backup
          if (!window.cascadeOriginalCode) {
            window.cascadeOriginalCode = {};
          }
          window.cascadeOriginalCode[containerId] = codeContent;
          console.log('üìù Backup code stored globally for container:', containerId);
          
          // Display the model
          this.displayModel(shape, containerId);
          
          // Update the loading message to success
          setTimeout(() => {
            loadingDiv.innerHTML = `
              <div style="padding: 10px; text-align: center; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; margin: 10px 0;">
                <p>‚úÖ <strong>Cascade Model ${index + 1}</strong> - Loaded Successfully</p>
              </div>
            `;
          }, 1000);
          
        } else {
          throw new Error('buildModel function did not return a valid shape');
        }
        
      } catch (error) {
        console.error(`‚ùå Error processing cascade block ${index + 1}:`, error);
        
        // Show error message in place of code block
        const errorDiv = document.createElement('div');
        errorDiv.innerHTML = `
          <div style="padding: 20px; text-align: center; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 10px 0;">
            <p>‚ùå <strong>Cascade Model ${index + 1} - Error</strong></p>
            <p><em>${error.message}</em></p>
            <details style="margin-top: 10px; text-align: left;">
              <summary>Show Code</summary>
              <pre style="background: #f8f9fa; padding: 10px; margin-top: 10px; border-radius: 4px; overflow-x: auto;"><code>${codeBlock.textContent || codeBlock.innerText}</code></pre>
            </details>
          </div>
        `;
        
        // Find the pre element containing this code block and replace it
        let preElement = codeBlock.parentElement;
        while (preElement && preElement.tagName !== 'PRE') {
          preElement = preElement.parentElement;
        }
        
        if (preElement) {
          preElement.parentNode.replaceChild(errorDiv, preElement);
        }
      }
    });
    
  }).catch(error => {
    console.error('‚ùå Failed to initialize cascade auto-detection:', error);
  });
};

// Auto-run cascade detection when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.cascadeViewer.autoDetectAndExecute();
  });
} else {
  // DOM is already ready
  window.cascadeViewer.autoDetectAndExecute();
}

</script>

