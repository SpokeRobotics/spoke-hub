{% comment %}
OpenCascade.js initialization include for Spoke documentation site.
Usage in any page:

  {% include ocjs_init.html container_id="my-viewer" %}

This include automatically creates a <div> with the specified container_id (default 'ocjs-viewer')
with responsive sizing and loads OpenCascade.js along with Three.js utilities.

After including this, you can:
1. Use window.ocjsReady Promise to access OpenCascade.js
2. Use window.cascadeViewer utilities for 3D visualization
3. Call window.cascadeViewer.displayModel(shape) to show any OpenCascade shape
{% endcomment %}

<!-- Viewer container -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}" style="width: 100%; height: 600px; max-width: 100%; margin: 0 auto; border: 1px solid #ccc;"></div>

<!-- Export buttons container (hidden by default) -->
<div id="{{ include.container_id | default: 'ocjs-viewer' }}-export-buttons" style="display: none; text-align: center; margin: 10px 0; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
  <p style="margin: 0 0 10px 0; font-weight: bold; color: #495057;">üìÅ Export Model:</p>
  <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-step" style="margin: 0 5px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">STEP</button>
  <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-stl" style="margin: 0 5px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">STL</button>
  <button id="{{ include.container_id | default: 'ocjs-viewer' }}-export-gltf" style="margin: 0 5px; padding: 8px 16px; background: #ffc107; color: black; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">GLTF</button>
</div>

<!-- Import map for OpenCascade.js and Three.js ES modules -->
<script type="importmap">
{
  "imports": {
    "opencascade.js": "https://unpkg.com/opencascade.js@1.1.1/dist/opencascade.wasm.js",
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<!-- Load OpenCascade.js and Three.js utilities -->
<script type="module">
import initOpenCascade from 'opencascade.js';
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

/**
 * window.ocjsReady is a Promise that resolves with the initialized OpenCascade.js module.
 */
window.ocjsReady = initOpenCascade({
  locateFile: function(path, prefix) {
    // Return the unpkg CDN path for WASM files
    if (path.endsWith('.wasm')) {
      return 'https://unpkg.com/opencascade.js@1.1.1/dist/' + path;
    }
    return prefix + path;
  }
}).then(oc => {
  console.log('OpenCascade.js loaded successfully from unpkg CDN');
  return oc;
}).catch(error => {
  console.error('Failed to load OpenCascade.js:', error);
  throw error;
});

/**
 * window.cascadeViewer provides utilities for CAD visualization
 */
window.cascadeViewer = {
  // Store current model data for export
  currentModelData: {
    shape: null,
    geometry: null,
    oc: null,
    containerId: null
  },

  // Show export buttons after successful model load
  showExportButtons: function(containerId) {
    const exportButtonsId = containerId + '-export-buttons';
    const exportButtons = document.getElementById(exportButtonsId);
    if (exportButtons) {
      exportButtons.style.display = 'block';
      console.log('‚úÖ Export buttons shown for container:', containerId);
    }
  },

  // Hide export buttons
  hideExportButtons: function(containerId) {
    const exportButtonsId = containerId + '-export-buttons';
    const exportButtons = document.getElementById(exportButtonsId);
    if (exportButtons) {
      exportButtons.style.display = 'none';
    }
  },

  // Setup export button event handlers
  setupExportHandlers: function(containerId) {
    const stepBtn = document.getElementById(containerId + '-export-step');
    const stlBtn = document.getElementById(containerId + '-export-stl');
    const gltfBtn = document.getElementById(containerId + '-export-gltf');

    if (stepBtn) {
      stepBtn.onclick = () => this.exportSTEP();
    }
    if (stlBtn) {
      stlBtn.onclick = () => this.exportSTL();
    }
    if (gltfBtn) {
      gltfBtn.onclick = () => this.exportGLTF();
    }
    console.log('‚úÖ Export button handlers setup for container:', containerId);
  },

  // Get page name for filename
  getPageName: function() {
    // Try to get page name from title, URL, or fallback to 'model'
    let pageName = 'model';
    
    // First try document title
    if (document.title) {
      pageName = document.title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
        .replace(/\s+/g, '-') // Replace spaces with hyphens
        .replace(/-+/g, '-') // Replace multiple hyphens with single
        .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
    }
    
    // Fallback to pathname if title is empty or generic
    if (!pageName || pageName === 'model' || pageName.length < 2) {
      const pathname = window.location.pathname;
      const pathParts = pathname.split('/').filter(part => part.length > 0);
      if (pathParts.length > 0) {
        pageName = pathParts[pathParts.length - 1]
          .replace(/\.html?$/, '') // Remove .html extension
          .replace(/[^a-z0-9-]/g, '') // Keep only alphanumeric and hyphens
          .toLowerCase();
      }
    }
    
    return pageName || 'model';
  },

  // Export functions (dummy implementations for now)
  exportSTEP: function() {
    console.log('üìÅ Exporting STEP file...');
    const filename = this.getPageName() + '.step';
    
    if (!this.currentModelData.shape || !this.currentModelData.oc) {
      console.error('‚ùå No OpenCascade shape data available for STEP export');
      alert('Error: No OpenCascade model data available for STEP export');
      return;
    }
    
    try {
      // First try experimental direct capture approach
      console.log('üß™ Trying experimental STEP capture first...');
      const stepContent = this.testDirectSTEPCapture(this.currentModelData.shape, this.currentModelData.oc, filename);
      
      if (stepContent && stepContent.includes('STEP')) {
        console.log('‚úÖ Experimental capture successful! Downloading file...');
        this.downloadFile(filename, stepContent, 'application/step');
        console.log('‚úÖ STEP export completed via experimental method:', filename);
        return;
      }
      
      // Fallback to original method if experimental fails
      console.log('üîÑ Experimental failed, falling back to original method...');
      this.generateSTEPContent(this.currentModelData.shape, this.currentModelData.oc, filename);
      console.log('‚úÖ STEP export initiated:', filename);
    } catch (error) {
      console.error('‚ùå Error exporting STEP:', error);
      alert('Error exporting STEP file: ' + error.message);
    }
  },

  exportSTL: function() {
    console.log('üìÅ Exporting STL file...');
    const filename = this.getPageName() + '.stl';
    
    if (!this.currentModelData.geometry) {
      console.error('‚ùå No geometry data available for STL export');
      alert('Error: No model data available for export');
      return;
    }
    
    try {
      const stlContent = this.generateSTLContent(this.currentModelData.geometry);
      this.downloadFile(filename, stlContent, 'model/stl');
      console.log('‚úÖ STL file exported successfully:', filename);
    } catch (error) {
      console.error('‚ùå Error exporting STL:', error);
      alert('Error exporting STL file: ' + error.message);
    }
  },

  exportGLTF: function() {
    console.log('üìÅ Exporting GLTF file...');
    const filename = this.getPageName() + '.gltf';
    
    if (!this.currentModelData.geometry) {
      console.error('‚ùå No geometry data available for GLTF export');
      alert('Error: No model data available for export');
      return;
    }
    
    try {
      this.generateGLTFContent(this.currentModelData.geometry, filename);
      console.log('‚úÖ GLTF export initiated:', filename);
    } catch (error) {
      console.error('‚ùå Error exporting GLTF:', error);
      alert('Error exporting GLTF file: ' + error.message);
    }
  },

  // Helper function to download dummy files
  downloadDummyFile: function(filename, content) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log('‚úÖ Downloaded dummy file:', filename);
  },

  // Helper function to download files with proper MIME types
  downloadFile: function(filename, content, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log('‚úÖ Downloaded file:', filename);
  },

  // Generate STL content from Three.js geometry
  generateSTLContent: function(geometry) {
    console.log('üîß Generating STL content from geometry...');
    
    const vertices = geometry.attributes.position.array;
    const indices = geometry.index ? geometry.index.array : null;
    const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
    
    let stlContent = 'solid OpenCascadeModel\n';
    
    // If geometry is indexed, use indices to create triangles
    if (indices) {
      for (let i = 0; i < indices.length; i += 3) {
        const i1 = indices[i] * 3;
        const i2 = indices[i + 1] * 3;
        const i3 = indices[i + 2] * 3;
        
        // Get vertices
        const v1 = [vertices[i1], vertices[i1 + 1], vertices[i1 + 2]];
        const v2 = [vertices[i2], vertices[i2 + 1], vertices[i2 + 2]];
        const v3 = [vertices[i3], vertices[i3 + 1], vertices[i3 + 2]];
        
        // Calculate normal if not provided
        let normal;
        if (normals) {
          normal = [normals[i1], normals[i1 + 1], normals[i1 + 2]];
        } else {
          // Calculate normal from cross product
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          // Normalize
          const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
        }
        
        stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
        stlContent += '    outer loop\n';
        stlContent += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
        stlContent += '    endloop\n';
        stlContent += '  endfacet\n';
      }
    } else {
      // Non-indexed geometry - process vertices in groups of 3
      for (let i = 0; i < vertices.length; i += 9) {
        const v1 = [vertices[i], vertices[i + 1], vertices[i + 2]];
        const v2 = [vertices[i + 3], vertices[i + 4], vertices[i + 5]];
        const v3 = [vertices[i + 6], vertices[i + 7], vertices[i + 8]];
        
        // Calculate normal
        let normal;
        if (normals) {
          normal = [normals[i], normals[i + 1], normals[i + 2]];
        } else {
          const u = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
          const v = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
          normal = [
            u[1] * v[2] - u[2] * v[1],
            u[2] * v[0] - u[0] * v[2],
            u[0] * v[1] - u[1] * v[0]
          ];
          const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
          if (length > 0) {
            normal[0] /= length;
            normal[1] /= length;
            normal[2] /= length;
          }
        }
        
        stlContent += `  facet normal ${normal[0].toFixed(6)} ${normal[1].toFixed(6)} ${normal[2].toFixed(6)}\n`;
        stlContent += '    outer loop\n';
        stlContent += `      vertex ${v1[0].toFixed(6)} ${v1[1].toFixed(6)} ${v1[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v2[0].toFixed(6)} ${v2[1].toFixed(6)} ${v2[2].toFixed(6)}\n`;
        stlContent += `      vertex ${v3[0].toFixed(6)} ${v3[1].toFixed(6)} ${v3[2].toFixed(6)}\n`;
        stlContent += '    endloop\n';
        stlContent += '  endfacet\n';
      }
    }
    
    stlContent += 'endsolid OpenCascadeModel\n';
    
    console.log(`‚úÖ Generated STL with ${indices ? indices.length / 3 : vertices.length / 9} triangles`);
    return stlContent;
  },

  // Generate GLTF content from Three.js geometry
  generateGLTFContent: function(geometry, filename) {
    console.log('üîß Generating GLTF content from geometry...');
    
    // Create a temporary scene with the geometry
    const scene = new THREE.Scene();
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x888888,
      metalness: 0.1,
      roughness: 0.8,
      opacity: 0.9
    });
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    
    // Use GLTFExporter to export the scene
    const exporter = new GLTFExporter();
    
    exporter.parse(
      scene,
      (gltfData) => {
        console.log('‚úÖ GLTF data generated successfully');
        
        // Convert to JSON string for text-based GLTF format
        const gltfString = JSON.stringify(gltfData, null, 2);
        
        // Download the GLTF file
        this.downloadFile(filename, gltfString, 'model/gltf+json');
        console.log(`‚úÖ GLTF file exported successfully: ${filename}`);
      },
      (error) => {
        console.error('‚ùå Error generating GLTF:', error);
        throw new Error('Failed to generate GLTF data: ' + error.message);
      },
      {
        binary: false, // Export as text-based GLTF, not GLB
        embedImages: true,
        truncateDrawRange: true
      }
    );
  },

  // EXPERIMENTAL: Test direct STEP data capture
  testDirectSTEPCapture: function(shape, oc, filename) {
    console.log('üß™ EXPERIMENTAL: Testing direct STEP data capture...');
    
    try {
      // Create STEP writer
      const writer = new oc.STEPControl_Writer_1();
      console.log('‚úÖ STEP writer created');
      
      // Transfer shape
      const transferResult = writer.Transfer(
        shape,
        oc.STEPControl_StepModelType.STEPControl_AsIs,
        true
      );
      console.log('‚úÖ Shape transferred:', transferResult);
      
      // Test 1: Try to capture data before writing to file
      console.log('üß™ Test 1: Checking writer internal data...');
      console.log('Writer properties:', Object.getOwnPropertyNames(writer));
      
      // Test 2: Try writing to a very simple filename
      console.log('üß™ Test 2: Writing to simple filename...');
      const simpleFile = 'test.step';
      const writeResult = writer.Write(simpleFile);
      console.log('Write result:', writeResult);
      
      // Test 3: Try different file reading approaches
      console.log('üß™ Test 3: Trying different read approaches...');
      
      // Approach A: Direct path
      try {
        const content1 = oc.FS.readFile(simpleFile, { encoding: 'utf8' });
        console.log('‚úÖ Direct path read successful:', content1.length, 'bytes');
        return content1;
      } catch (e) {
        console.log('‚ùå Direct path failed:', e.message);
      }
      
      // Approach B: Root path
      try {
        const content2 = oc.FS.readFile('/' + simpleFile, { encoding: 'utf8' });
        console.log('‚úÖ Root path read successful:', content2.length, 'bytes');
        return content2;
      } catch (e) {
        console.log('‚ùå Root path failed:', e.message);
      }
      
      // Approach C: List all files and find any STEP-like content
      try {
        const allFiles = oc.FS.readdir('/');
        console.log('üìÅ All files in root:', allFiles);
        
        for (const file of allFiles) {
          if (typeof file === 'string' && file.length > 0) {
            try {
              const testContent = oc.FS.readFile('/' + file, { encoding: 'utf8' });
              if (testContent.includes('STEP') || testContent.includes('FILE_DESCRIPTION')) {
                console.log('‚úÖ Found STEP content in file:', file, testContent.length, 'bytes');
                return testContent;
              }
            } catch (readErr) {
              // Ignore read errors for non-text files
            }
          }
        }
      } catch (e) {
        console.log('‚ùå Directory listing failed:', e.message);
      }
      
      throw new Error('All experimental approaches failed');
      
    } catch (error) {
      console.error('üß™ Experimental capture failed:', error);
      throw error;
    }
  },

  // Generate STEP content from OpenCascade shape using research-based approach
  generateSTEPContent: function(shape, oc, filename) {
    console.log('üîß Generating STEP content using research-based approach...');
    
    try {
      // Create STEP writer using the working pattern from Stack Overflow
      console.log('üîß Creating STEPControl_Writer_1...');
      const writer = new oc.STEPControl_Writer_1();
      console.log('‚úÖ STEP writer created successfully');
      
      // Debug what progress range classes are available
      console.log('üîç Checking available Message/Progress classes...');
      const progressClasses = [];
      for (let key in oc) {
        if (key.includes('Message') || key.includes('Progress')) {
          progressClasses.push(key);
        }
      }
      console.log('üìÅ Available progress classes:', progressClasses);
      
      // Try different approaches for the Transfer method
      console.log('üì¶ Attempting Transfer with different progress parameters...');
      let transferResult = null;
      
      // Attempt 1: Try without progress parameter (3 arguments)
      try {
        console.log('üîÑ Attempt 1: Transfer with 3 arguments (no progress)');
        transferResult = writer.Transfer(
          shape,
          oc.STEPControl_StepModelType.STEPControl_AsIs,
          true
        );
        console.log('‚úÖ Transfer successful with 3 arguments');
      } catch (e) {
        console.log('‚ùå 3-argument transfer failed:', e.message);
        
        // Attempt 2: Try with different progress class constructors
        const progressAttempts = [
          () => new oc.Message_ProgressRange(),
          () => new oc.Message_ProgressRange_1(),
          () => new oc.Message_ProgressRange_2(),
          () => oc.Message_ProgressRange_1 ? oc.Message_ProgressRange_1() : null,
          () => null // Try with null progress
        ];
        
        for (let i = 0; i < progressAttempts.length; i++) {
          try {
            const progressObj = progressAttempts[i]();
            console.log(`üîÑ Attempt ${i + 2}: Transfer with progress attempt ${i + 1}`);
            transferResult = writer.Transfer(
              shape,
              oc.STEPControl_StepModelType.STEPControl_AsIs,
              true,
              progressObj
            );
            console.log(`‚úÖ Transfer successful with progress attempt ${i + 1}`);
            break;
          } catch (progressError) {
            console.log(`‚ùå Progress attempt ${i + 1} failed:`, progressError.message);
          }
        }
      }
      
      if (transferResult === null) {
        throw new Error('All Transfer attempts failed');
      }
      
      // Try different approaches to get STEP data directly
      console.log('üîÑ Attempting direct STEP export approaches...');
      let stepContent = null;
      
      // Approach 1: Try WriteStream if available
      console.log('üîÑ Approach 1: Checking for WriteStream method...');
      if (typeof writer.WriteStream === 'function') {
        console.log('‚úÖ WriteStream method found, attempting direct stream export...');
        try {
          // This would be ideal but may not be available in OpenCascade.js
          stepContent = writer.WriteStream();
          console.log('‚úÖ WriteStream successful!');
        } catch (e) {
          console.log('‚ùå WriteStream failed:', e.message);
        }
      } else {
        console.log('‚ùå WriteStream method not available');
      }
      
      // Approach 2: Try accessing the Model with proper arguments
      if (!stepContent) {
        console.log('üîÑ Approach 2: Attempting to access Model data with arguments...');
        try {
          // Model() might need a boolean argument
          const model = writer.Model(true);
          if (model) {
            console.log('‚úÖ Model object retrieved with argument');
            
            // Try different methods directly (Emscripten objects don't show methods in getOwnPropertyNames)
            const methodsToTry = [
              { name: 'WriteString', args: [] },
              { name: 'ToString', args: [] },
              { name: 'Print', args: [] },
              { name: 'Dump', args: [] },
              { name: 'WriteStep', args: [] },
              { name: 'WriteFile', args: ['temp.step'] }
            ];
            
            for (const methodInfo of methodsToTry) {
              try {
                console.log(`üîÑ Trying Model.${methodInfo.name}(${methodInfo.args.join(', ')})...`);
                const result = model[methodInfo.name](...methodInfo.args);
                if (result && typeof result === 'string' && result.length > 100) {
                  stepContent = result;
                  console.log(`‚úÖ Model.${methodInfo.name}() successful! (${stepContent.length} bytes)`);
                  break;
                } else if (result) {
                  console.log(`üìä Model.${methodInfo.name}() returned:`, typeof result, result);
                }
              } catch (methodError) {
                console.log(`‚ùå Model.${methodInfo.name}() failed:`, methodError.message);
              }
            }
          }
        } catch (e) {
          console.log('‚ùå Model access failed:', e.message);
        }
      }
      
      // Approach 3: Try accessing WorkSession data
      if (!stepContent) {
        console.log('üîÑ Approach 3: Attempting to access WorkSession data...');
        try {
          const workSession = writer.WS();
          if (workSession) {
            console.log('‚úÖ WorkSession object retrieved');
            
            // Try different WorkSession methods directly
            const wsMethods = [
              { name: 'Model', args: [] },
              { name: 'PrintTransferInfo', args: [] },
              { name: 'MapWriter', args: [] }
            ];
            
            for (const methodInfo of wsMethods) {
              try {
                console.log(`üîÑ Trying WorkSession.${methodInfo.name}()...`);
                const wsResult = workSession[methodInfo.name](...methodInfo.args);
                if (wsResult) {
                  console.log(`‚úÖ WorkSession.${methodInfo.name}() returned object`);
                  
                  // If we got a model-like object, try to get STEP data from it
                  if (methodInfo.name === 'Model' || methodInfo.name === 'MapWriter') {
                    const modelMethods = ['WriteString', 'ToString', 'Print', 'WriteStep'];
                    for (const modelMethod of modelMethods) {
                      try {
                        console.log(`üîÑ Trying ${methodInfo.name}.${modelMethod}()...`);
                        const modelResult = wsResult[modelMethod]();
                        if (modelResult && typeof modelResult === 'string' && modelResult.length > 100) {
                          stepContent = modelResult;
                          console.log(`‚úÖ ${methodInfo.name}.${modelMethod}() successful! (${stepContent.length} bytes)`);
                          break;
                        }
                      } catch (modelError) {
                        console.log(`‚ùå ${methodInfo.name}.${modelMethod}() failed:`, modelError.message);
                      }
                    }
                    if (stepContent) break;
                  }
                }
              } catch (wsError) {
                console.log(`‚ùå WorkSession.${methodInfo.name}() failed:`, wsError.message);
              }
            }
          }
        } catch (e) {
          console.log('‚ùå WorkSession access failed:', e.message);
        }
      }
      
      // Approach 4: Try with a simple filename and virtual filesystem
      if (!stepContent) {
        console.log('üîÑ Approach 4: Simple filename virtual filesystem approach...');
        const simpleFilename = 'export.step';
        try {
          console.log('üíæ Writing with simple filename:', simpleFilename);
          writer.Write(simpleFilename);
          
          // Try to read immediately
          stepContent = oc.FS.readFile('/' + simpleFilename, { encoding: 'utf8' });
          console.log(`‚úÖ Simple filename approach successful! (${stepContent.length} bytes)`);
        } catch (e) {
          console.log('‚ùå Simple filename approach failed:', e.message);
          
          // Last resort: check what files actually exist and try to read them
          try {
            const files = oc.FS.readdir('/');
            console.log('üìÅ Available files after write:', files);
            
            // Try to read any file that might be the STEP file (including empty names)
            for (const file of files) {
              if (typeof file === 'string' && (file.includes('step') || file.includes('stp') || file === '')) {
                try {
                  const filePath = file === '' ? '/' : '/' + file;
                  stepContent = oc.FS.readFile(filePath, { encoding: 'utf8' });
                  if (stepContent && stepContent.includes('STEP')) {
                    console.log(`‚úÖ Found and read STEP file: "${file}" (${stepContent.length} bytes)`);
                    break;
                  }
                } catch (readError) {
                  console.log(`‚ùå Could not read "${file}":`, readError.message);
                }
              }
            }
          } catch (dirError) {
            console.log('‚ùå Could not list directory:', dirError.message);
          }
        }
      }
      
      if (!stepContent) {
        throw new Error('All STEP export approaches failed');
      }
      
      // Download the file
      this.downloadFile(filename, stepContent, 'application/step');
      console.log('‚úÖ Research-based STEP file exported:', filename);
      
      // Clean up the temporary file
      try {
        oc.FS.unlink('/' + filename);
        console.log('‚úÖ Temporary file cleaned up');
      } catch (cleanupError) {
        console.warn('‚ö†Ô∏è Could not clean up temporary file:', cleanupError.message);
      }
      
      // Download the STEP file
      this.downloadFile(filename, stepContent, 'application/step');
      console.log(`‚úÖ STEP file exported successfully: ${filename} (${stepContent.length} bytes)`);
      
    } catch (error) {
      console.error('‚ùå Error in research-based STEP generation:', error);
      
      // Fallback: Try alternative STEP export method
      console.log('üîÑ Attempting fallback STEP export method...');
      try {
        this.generateSTEPContentFallback(shape, oc, filename);
      } catch (fallbackError) {
        console.error('‚ùå Fallback STEP export also failed:', fallbackError);
        throw new Error('STEP export failed: ' + error.message + ' (Fallback also failed: ' + fallbackError.message + ')');
      }
    }
  },

  // Fallback STEP generation method
  generateSTEPContentFallback: function(shape, oc, filename) {
    console.log('üîÑ Using fallback STEP generation method...');
    
    // Create a basic STEP file header and content
    const stepHeader = `ISO-10303-21;
HEADER;
FILE_DESCRIPTION(('OpenCascade.js Generated Model'),'2;1');
FILE_NAME('${filename}','${new Date().toISOString()}',('OpenCascade.js'),('Spoke CAD Viewer'),'OpenCascade.js','OpenCascade.js','');
FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));
ENDSEC;

DATA;
`;
    
    const stepFooter = `ENDSEC;
END-ISO-10303-21;
`;
    
    // For now, create a minimal STEP file with basic shape information
    // This is a simplified fallback - a full STEP export would require
    // extensive geometry analysis and STEP entity creation
    const stepContent = stepHeader + 
      `#1 = CARTESIAN_POINT('Origin',(0.0,0.0,0.0));
` +
      `#2 = DIRECTION('Z-Axis',(0.0,0.0,1.0));
` +
      `#3 = DIRECTION('X-Axis',(1.0,0.0,0.0));
` +
      `#4 = AXIS2_PLACEMENT_3D('Placement',#1,#2,#3);
` +
      `/* OpenCascade.js Shape Export - Simplified STEP Format */
` +
      `/* Original shape type: ${shape.ShapeType()} */
` +
      stepFooter;
    
    // Download the fallback STEP file
    this.downloadFile(filename, stepContent, 'application/step');
    console.log(`‚úÖ Fallback STEP file exported: ${filename}`);
  },

  // Convert OpenCascade shape to Three.js mesh data
  convertOpenCascadeToMesh: function(shape, oc) {
    console.log('üîß Converting OpenCascade shape to mesh...');
    
    try {
      // Use OpenCascade's meshing capabilities
      console.log('üîß Creating mesher...');
      const mesher = new oc.BRepMesh_IncrementalMesh_2(shape, 0.1, false, 0.5, false);
      console.log('üîß Performing mesh operation...');
      mesher.Perform();
      
      if (!mesher.IsDone()) {
        throw new Error('Failed to mesh the OpenCascade shape');
      }
      console.log('‚úÖ Meshing completed successfully');
      
      const vertices = [];
      const indices = [];
      const normals = [];
      
      // Iterate through faces to extract mesh data
      console.log('üîç Exploring faces...');
      const faceExplorer = new oc.TopExp_Explorer_2(shape, oc.TopAbs_ShapeEnum.TopAbs_FACE, oc.TopAbs_ShapeEnum.TopAbs_SHAPE);
      
      let vertexOffset = 0;
      let faceCount = 0;
      
      while (faceExplorer.More()) {
        faceCount++;
        console.log(`  Processing face ${faceCount}...`);
        
        const face = oc.TopoDS.Face_1(faceExplorer.Current());
        const location = new oc.TopLoc_Location_1();
        const triangulation = oc.BRep_Tool.Triangulation(face, location);
        
        if (!triangulation.IsNull()) {
          console.log(`  Face ${faceCount} has triangulation data`);
          const transform = location.Transformation();
          
          // Get node and triangle counts using correct API
          const nodeCount = triangulation.get().NbNodes();
          const triangleCount = triangulation.get().NbTriangles();
          console.log(`    Nodes: ${nodeCount}, Triangles: ${triangleCount}`);
          
          // Extract vertices
          for (let i = 1; i <= nodeCount; i++) {
            const node = triangulation.get().Node(i);
            const transformedNode = node.Transformed(transform);
            vertices.push(transformedNode.X(), transformedNode.Y(), transformedNode.Z());
          }
          
          // Process each triangle in the face with corrected orientation
          for (let t = 1; t <= triangleCount; t++) {
            const triangle = triangulation.get().Triangle(t);
            const n1 = triangle.Value(1);
            const n2 = triangle.Value(2);
            const n3 = triangle.Value(3);
            
            // Get triangle vertices
            const v1 = triangulation.get().Node(n1).Transformed(transform);
            const v2 = triangulation.get().Node(n2).Transformed(transform);
            const v3 = triangulation.get().Node(n3).Transformed(transform);
            
            // Compute triangle normal using cross product
            const edge1 = new THREE.Vector3(
              v2.X() - v1.X(),
              v2.Y() - v1.Y(),
              v2.Z() - v1.Z()
            );
            const edge2 = new THREE.Vector3(
              v3.X() - v1.X(),
              v3.Y() - v1.Y(),
              v3.Z() - v1.Z()
            );
            
            let normal = edge1.cross(edge2).normalize();
            
            // Get face orientation from OpenCascade
            const faceOrientation = face.Orientation_1();
            
            // Check if face is reversed according to OpenCascade
            const isReversed = (faceOrientation === oc.TopAbs_Orientation.TopAbs_REVERSED);
            
            if (isReversed) {
              // Face is reversed, flip normal and triangle winding
              normal.negate();
              indices.push(
                vertexOffset + n1 - 1,
                vertexOffset + n3 - 1,  // Swapped n2 and n3 for reversed winding
                vertexOffset + n2 - 1
              );
            } else {
              // Face is forward, keep original normal and winding
              indices.push(
                vertexOffset + n1 - 1,
                vertexOffset + n2 - 1,
                vertexOffset + n3 - 1
              );
            }
            
            // Add the corrected normal for all three vertices of the triangle
            for (let j = 0; j < 3; j++) {
              normals.push(normal.x, normal.y, normal.z);
            }
          }
          
          vertexOffset += nodeCount;
        } else {
          console.log(`  Face ${faceCount} has no triangulation data`);
        }
        
        faceExplorer.Next();
      }
      
      console.log(`üîç Extracted ${vertices.length / 3} vertices, ${indices.length / 3} triangles from ${faceCount} faces`);
      
      if (vertices.length === 0) {
        throw new Error('No vertices extracted from OpenCascade shape');
      }
      
      // Create Three.js geometry
      console.log('üîß Creating Three.js BufferGeometry...');
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geometry.setIndex(indices);
      
      console.log('‚úÖ Three.js geometry created successfully');
      return geometry;
      
    } catch (error) {
      console.error('‚ùå Error in convertOpenCascadeToMesh:', error);
      throw error;
    }
  },

  // Export geometry to GLB format
  exportToGLB: function(geometry) {
    return new Promise((resolve, reject) => {
      console.log('üì¶ Exporting geometry to GLB...');
      
      try {
        const material = new THREE.MeshStandardMaterial({ 
          color: 0x808080,
          metalness: 0.1,
          roughness: 0.4,
          transparent: false,
          opacity: 1.0
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        const scene = new THREE.Scene();
        scene.add(mesh);
        
        console.log('üì¶ Creating GLTFExporter...');
        const exporter = new GLTFExporter();
        exporter.parse(
          scene,
          (gltf) => {
            console.log('‚úÖ GLB export successful, size:', gltf.byteLength, 'bytes');
            resolve(gltf);
          },
          (error) => {
            console.error('‚ùå GLB export failed:', error);
            reject(error);
          },
          { binary: true }
        );
      } catch (error) {
        console.error('‚ùå Error setting up GLB export:', error);
        reject(error);
      }
    });
  },

  // Load GLB and display in Three.js viewer
  loadGLBAndDisplay: function(glbData, containerId = 'viewer') {
    console.log('üé¨ Loading GLB data into Three.js viewer...');
    
    const container = document.getElementById(containerId);
    
    // === Initialize Three.js Scene ===
    console.log('üé¨ Initializing Three.js scene...');
    
    if (!container) {
      console.error('‚ùå Viewer container not found');
      return;
    }
    
    // Clear previous content to prevent WebGL context conflicts
    container.innerHTML = '';
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    
    // Create camera with proper aspect ratio
    const containerRect = container.getBoundingClientRect();
    const camera = new THREE.PerspectiveCamera(
      75, 
      containerRect.width / containerRect.height, 
      0.1, 
      1000
    );
    
    // Position camera for good viewing angle
    camera.position.set(80, 60, 80);
    camera.lookAt(24, 16, 18);
    
    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRect.width, containerRect.height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Append renderer to cleared container
    container.appendChild(renderer.domElement);
    
    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(24, 16, 18);
    controls.update();
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Load the GLB data
    console.log('üì¶ Loading GLB data...');
    const loader = new GLTFLoader();
    const blob = new Blob([glbData], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    
    loader.load(
      url,
      (gltf) => {
        console.log('‚úÖ GLB loaded successfully');
        const model = gltf.scene;
        
        scene.add(model);
        console.log('‚úÖ Model added to scene');
        
        // Add wireframe overlay
        model.traverse((child) => {
          if (child.isMesh) {
            const wireframe = new THREE.WireframeGeometry(child.geometry);
            const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
              color: 0xFFFFFF, 
              opacity: 0.3, 
              transparent: true 
            }));
            scene.add(line);
            
            // Store references for animation
            window.cadModel = model;
            window.cadWireframe = line;
            console.log('‚úÖ Wireframe overlay added');
          }
        });
        
        // Clean up blob URL
        URL.revokeObjectURL(url);
        
        console.log('‚úÖ Model setup completed successfully!');
        
        // Show export buttons and setup handlers after successful load
        window.cascadeViewer.setupExportHandlers(containerId);
        window.cascadeViewer.showExportButtons(containerId);
      },
      (progress) => {
        console.log('üìä Loading progress:', progress);
      },
      (error) => {
        console.error('‚ùå Error loading GLB:', error);
        URL.revokeObjectURL(url);
      }
    );
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      // Rotate the CAD model and wireframe if they exist
      if (window.cadModel && window.cadWireframe) {
        window.cadModel.rotation.x += 0.005;
        window.cadModel.rotation.y += 0.005;
        window.cadWireframe.rotation.x += 0.005;
        window.cadWireframe.rotation.y += 0.005;
      }
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
    console.log('üé¨ Animation loop started');
  },

  // Fallback: Direct Three.js visualization (skip GLB export/import)
  directThreeJSVisualization: function(geometry, containerId = 'viewer') {
    console.log('üéØ Using direct Three.js visualization fallback...');
    
    const container = document.getElementById(containerId);
    
    // Check if a renderer already exists and dispose of it properly
    if (window.threeJSRenderer) {
      console.log('üßπ Disposing existing Three.js renderer');
      window.threeJSRenderer.dispose();
      window.threeJSRenderer = null;
    }
    
    // Clear any existing content completely
    container.innerHTML = '';
    
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(100, 100, 100);
    
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      alpha: false,
      preserveDrawingBuffer: false,
      powerPreference: "high-performance"
    });
    
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Store renderer globally for cleanup
    window.threeJSRenderer = renderer;
    
    // Add renderer canvas to container
    container.appendChild(renderer.domElement);
    
    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
    
    // Create mesh from OpenCascade-derived geometry
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x808080,
      metalness: 0.1,
      roughness: 0.4,
      transparent: true,
      opacity: 0.9
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    
    // Add wireframe overlay
    const wireframe = new THREE.WireframeGeometry(geometry);
    const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ 
      color: 0x000000, 
      opacity: 0.3, 
      transparent: true 
    }));
    scene.add(line);
    
    // Store references for animation
    window.cadModel = mesh;
    window.cadWireframe = line;
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      
      mesh.rotation.x += 0.005;
      mesh.rotation.y += 0.005;
      line.rotation.x += 0.005;
      line.rotation.y += 0.005;
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
    
    animate();
    console.log('‚úÖ Direct Three.js visualization completed successfully!');
    
    // Show export buttons and setup handlers after successful fallback load
    this.setupExportHandlers(containerId);
    this.showExportButtons(containerId);
  },

  // Main function to display any OpenCascade shape
  displayModel: async function(shape, containerId = 'viewer') {
    try {
      console.log('üöÄ Starting OpenCascade.js ‚Üí GLB ‚Üí Three.js workflow...');
      
      const oc = await window.ocjsReady;
      
      // Store model data for export
      this.currentModelData = {
        shape: shape,
        geometry: null,
        oc: oc,
        containerId: containerId
      };
      
      // Hide export buttons initially
      this.hideExportButtons(containerId);
      
      // Step 1: Convert OpenCascade shape to Three.js geometry
      console.log('üîß Step 1: Converting OpenCascade shape to mesh...');
      const geometry = this.convertOpenCascadeToMesh(shape, oc);
      
      // Store geometry for export
      this.currentModelData.geometry = geometry;
      
      // Try GLB workflow first
      try {
        console.log('üì¶ Step 2: Attempting GLB export/import workflow...');
        // Step 2: Export geometry to GLB
        const glbData = await this.exportToGLB(geometry);
        
        // Step 3: Load GLB and display in Three.js
        this.loadGLBAndDisplay(glbData, containerId);
        
        console.log('‚úÖ CAD viewer GLB workflow completed successfully!');
        
      } catch (glbError) {
        console.warn('‚ö†Ô∏è GLB workflow failed, falling back to direct visualization:', glbError);
        
        // Fallback: Direct Three.js visualization
        this.directThreeJSVisualization(geometry, containerId);
        
        console.log('‚úÖ CAD viewer fallback workflow completed successfully!');
      }
      
    } catch (error) {
      console.error('‚ùå Error in CAD viewer workflow:', error);
      
      // Ultimate fallback display
      const container = document.getElementById(containerId);
      container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f0f0f0; color: #333; font-family: Arial, sans-serif;">
          <div style="text-align: center;">
            <h3>üîß OpenCascade.js ‚Üí Three.js Workflow</h3>
            <p>OpenCascade shape created successfully!</p>
            <p><em>‚ö†Ô∏è 3D viewer encountered an error during processing. Check console for details.</em></p>
            <p><strong>Error:</strong> ${error.message}</p>
          </div>
        </div>
      `;
    }
  }
};

console.log('‚úÖ Cascade viewer utilities loaded successfully!');

/**
 * Auto-detect and execute cascade code blocks
 */
window.cascadeViewer.autoDetectAndExecute = function() {
  // Wait for OpenCascade to be ready
  window.ocjsReady.then(oc => {
    console.log('üîç Scanning for cascade code blocks...');
    
    // Find all code elements with language-cascade class
    const cascadeBlocks = document.querySelectorAll('code.language-cascade');
    
    if (cascadeBlocks.length === 0) {
      console.log('‚ÑπÔ∏è No cascade code blocks found on this page');
      return;
    }
    
    console.log(`üéØ Found ${cascadeBlocks.length} cascade code block(s)`);
    
    // Process each cascade block
    cascadeBlocks.forEach((codeBlock, index) => {
      try {
        console.log(`üöÄ Processing cascade block ${index + 1}...`);
        
        // Get the code content
        const codeContent = codeBlock.textContent || codeBlock.innerText;
        console.log(`üìù Code content (${codeContent.length} chars):`, codeContent.substring(0, 100) + '...');
        
        // Find the container for this code block (look for nearby viewer divs)
        let containerId = 'viewer'; // default
        
        // Look for a viewer div near this code block
        let parent = codeBlock.parentElement;
        while (parent && parent !== document.body) {
          const viewerDiv = parent.querySelector('div[id*="viewer"]');
          if (viewerDiv) {
            containerId = viewerDiv.id;
            console.log(`üéØ Found viewer container: ${containerId}`);
            break;
          }
          parent = parent.parentElement;
        }
        
        // Create a function wrapper and execute the code
        const functionWrapper = `
          (function(oc) {
            ${codeContent}
            
            // Expect a buildModel function to be defined
            if (typeof buildModel === 'function') {
              return buildModel(oc);
            } else {
              throw new Error('cascade code block must define a buildModel(oc) function that returns a shape');
            }
          })
        `;
        
        console.log('üîß Executing cascade code...');
        const executeCode = eval(functionWrapper);
        const shape = executeCode(oc);
        
        if (shape) {
          console.log('‚úÖ Model built successfully, displaying...');
          
          // Replace the code block with a loading message
          const loadingDiv = document.createElement('div');
          loadingDiv.innerHTML = `
            <div style="padding: 20px; text-align: center; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; margin: 10px 0;">
              <p>üöÄ <strong>Cascade Model ${index + 1}</strong></p>
              <p>Loading 3D viewer...</p>
            </div>
          `;
          
          // Find the pre element containing this code block and replace it
          let preElement = codeBlock.parentElement;
          while (preElement && preElement.tagName !== 'PRE') {
            preElement = preElement.parentElement;
          }
          
          if (preElement) {
            preElement.parentNode.replaceChild(loadingDiv, preElement);
          }
          
          // Display the model
          this.displayModel(shape, containerId);
          
          // Update the loading message to success
          setTimeout(() => {
            loadingDiv.innerHTML = `
              <div style="padding: 10px; text-align: center; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; margin: 10px 0;">
                <p>‚úÖ <strong>Cascade Model ${index + 1}</strong> - Loaded Successfully</p>
              </div>
            `;
          }, 1000);
          
        } else {
          throw new Error('buildModel function did not return a valid shape');
        }
        
      } catch (error) {
        console.error(`‚ùå Error processing cascade block ${index + 1}:`, error);
        
        // Show error message in place of code block
        const errorDiv = document.createElement('div');
        errorDiv.innerHTML = `
          <div style="padding: 20px; text-align: center; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 10px 0;">
            <p>‚ùå <strong>Cascade Model ${index + 1} - Error</strong></p>
            <p><em>${error.message}</em></p>
            <details style="margin-top: 10px; text-align: left;">
              <summary>Show Code</summary>
              <pre style="background: #f8f9fa; padding: 10px; margin-top: 10px; border-radius: 4px; overflow-x: auto;"><code>${codeBlock.textContent || codeBlock.innerText}</code></pre>
            </details>
          </div>
        `;
        
        // Find the pre element containing this code block and replace it
        let preElement = codeBlock.parentElement;
        while (preElement && preElement.tagName !== 'PRE') {
          preElement = preElement.parentElement;
        }
        
        if (preElement) {
          preElement.parentNode.replaceChild(errorDiv, preElement);
        }
      }
    });
    
  }).catch(error => {
    console.error('‚ùå Failed to initialize cascade auto-detection:', error);
  });
};

// Auto-run cascade detection when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.cascadeViewer.autoDetectAndExecute();
  });
} else {
  // DOM is already ready
  window.cascadeViewer.autoDetectAndExecute();
}

</script>

